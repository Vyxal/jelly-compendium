[
  {
    "symbol": "©",
    "id": "copy-to-register",
    "name": "Copy To Register",
    "arity": -1,
    "keywords": ["register"],
    "tags": ["register", "hyper"],
    "tagline": "Save the result of a link to the <a href='/misc/register'>register</a> when it is called.",
    "description": "Given a link of any arity, return a link of the same arity that returns the exact same value. When it is run, the result is saved to the register.",
    "syntax": [["<link>©", "a link functionally identical to <code>&lt;link&gt;</code> that saves its result to the register"]]
  },
  {
    "symbol": "ß",
    "id": "recurse",
    "name": "This Link / Recurse",
    "arity": -3,
    "keywords": ["this", "link", "recurse", "call", "self"],
    "tags": ["nth-link"],
    "tagline": "Call this link with the same arity.",
    "description": "Technically, the resulting link is variadic, which means that if certain quicks are applied to <code>ß</code>, its arity may not actually be the same as the link's, but rather coerced into another arity.",
    "syntax": []
  },
  {
    "symbol": "¢",
    "id": "last-link-nilad",
    "name": "Last Link as a Nilad",
    "arity": 0,
    "keywords": ["last", "link", "niladically", "call"],
    "tags": ["nth-link"],
    "tagline": "Call the last link niladically.",
    "description": "",
    "syntax": []
  },
  {
    "symbol": "Ç",
    "id": "last-link-monad",
    "name": "Last Link as a Monad",
    "arity": 1,
    "keywords": ["last", "link", "monadically", "call"],
    "tags": ["nth-link"],
    "tagline": "Call the last link monadically.",
    "description": "",
    "syntax": []
  },
  {
    "symbol": "ç",
    "id": "last-link-dyad",
    "name": "Last Link as a Dyad",
    "arity": 2,
    "keywords": ["last", "link", "dyadically", "call"],
    "tags": ["nth-link"],
    "tagline": "Call the last link dyadically.",
    "description": "",
    "syntax": []
  },
  {
    "symbol": "Ñ",
    "id": "next-link-monad",
    "name": "Next Link as a Monad",
    "arity": 1,
    "keywords": ["next", "link", "monadically", "call"],
    "tags": ["nth-link"],
    "tagline": "Call the next link monadically.",
    "description": "",
    "syntax": []
  },
  {
    "symbol": "ñ",
    "id": "next-link-dyad",
    "name": "Next Link as a Dyad",
    "arity": 2,
    "keywords": ["next", "link", "dyadically", "call"],
    "tags": ["nth-link"],
    "tagline": "Call the next link dyadically.",
    "description": "",
    "syntax": []
  },
  {
    "symbol": "£",
    "id": "nth-link-nilad",
    "name": "N<sup>th</sup> Link as a Nilad",
    "arity": -1,
    "keywords": ["nth", "link", "index", "niladically", "call"],
    "tags": ["nth-link", "number"],
    "tagline": "Call the link at the specified index niladically.",
    "description": "The arity of the resulting link is actually equal to that of the consumed link; it is not always a nilad.",
    "syntax": [["<link>£", "a link with the same arity that niladically calls the link at the index returned by <code>&lt;link&gt;</code>"]]
  },
  {
    "symbol": "Ŀ",
    "id": "nth-link-monad",
    "name": "N<sup>th</sup> Link as a Monad",
    "arity": -2,
    "keywords": ["nth", "link", "index", "monadically", "call"],
    "tags": ["nth-link", "number"],
    "tagline": "Call the link at the specified index monadically.",
    "description": "The arity of the resulting link is actually equal to the maximum of that of the consumed link and 1; it is not always a monad.",
    "syntax": [["<nilad>Ŀ", "a monadic link that monadically calls the link at the specified index"], ["<monad/dyad>Ŀ", "a link with the same arity that monadically calls the link at the index returned by <code>&lt;link&gt;</code>"]]
  },
  {
    "symbol": "ŀ",
    "id": "nth-link-dyad",
    "name": "N<sup>th</sup> Link as a Dyad",
    "arity": 2,
    "keywords": ["nth", "link", "index", "dyadically", "call"],
    "tags": ["nth-link", "number"],
    "tagline": "Call the link at the specified index dyadically.",
    "description": "",
    "syntax": [["<nilad>ŀ", "a dyadic link that dyadically calls the link at the specified index"], ["<monad>ŀ", "a dyadic link that dyadically calls the link at the index returned by calling <code>&lt;monad&gt;</code> on its left argument"], ["<dyad>ŀ", "a dyadic link that dyadically calls the link at the index retuend by calling <code>&lt;dyad&gt;</code>"]]
  },
  {
    "symbol": "¦",
    "id": "apply-at-indices",
    "name": "Apply At Indices",
    "arity": -2,
    "keywords": ["apply", "indices", "indexes", "specific", "specified"],
    "tags": ["array", "number"],
    "tagline": "Apply a link to the specified indices. This description is actually misleading - read the description for more details on how it works exactly.",
    "description": "This does not actually just apply a link to elements at specific indices of a list. Rather, it first applies the link to the list itself. Then, it merges the original and the resulting list together - at each index of the original list, if it is in the set of indices to apply to, it selects the resulting value, and otherwise, it selects the original value. The result list is repeated as many times as necessary. If you need to apply a non-vectorizing link to specific elements, like taking the length of the first and third item, use <a href='/each'><code>€</code> (Each)</a>.<br /><br />Consider the following example: <code>1,3,2,1,3,2,3,2 M 2,3,5 ¦</code>. Firstly, we evaluate <a href='/atoms/indices-of-max'><code>M</code> (Indices of Maximal Elements)</a> on <code>[1, 3, 2, 1, 3, 2, 3, 2]</code>. This returns <code>[2, 5, 7]</code>. Then, we repeat the result list, line up the elements, and select the resulting element for indices <code>2, 3, 5</code> and the original element everywhere else:<br /><br /><pre><code class='language-plaintext'>[1, 3, 2, 1, 3, 2, 3, 2]\n[2, 5, 7, 2, 5, 7, 2, 5]\n ↓  ↓  ↓  ↓  ↓  ↓  ↓  ↓\n 1 [2][3] 4 [5] 6  7  8\n ↓  ↓  ↓  ↓  ↓  ↓  ↓  ↓\n[1, 5, 7, 1, 5, 2, 3, 2]</code></pre><p>(<a href='/tio#WyIiLCIxLDMsMiwxLDMsMiwzLDIgTSAyLDMsNSDCpiIsIiIsIiIsW11d'>Try It Online!</a>)</p>",
    "syntax": [["<link><indices>¦", "a link whose arity is the maximum of <code>&lt;link&gt;</code>'s, <code>&lt;indices&gt;</code>'s, and <code>1</code>, which applies the link to the specified indices as per the description"]]
  },
  {
    "symbol": "¡",
    "id": "ntimes",
    "name": "Repeat N Times",
    "arity": -1,
    "keywords": ["repeat", "ntimes", "loop"],
    "tags": ["number"],
    "tagline": "Apply a link N times.",
    "description": "If the link is dyadic, after the first iteration, the previous result is the left argument and the result before that (the left argument is the initial result) is the right argument. For example, <code>1 ,1¡ 2</code> returns <code>[1, 2]</code> as expected. Then, <code>1 ,2¡ 2</code> returns <code>[[1, 2], 1]</code> since the left argument is the previous result and the right argument is the result before that. Then, <code>1 ,3¡ 2</code> is <code>[[[1, 2], 1], [1, 2]]</code>, etc.",
    "syntax": [["<link><iterations>¡", "a link whose arity is the maximum of <code>&lt;link&gt;</code>'s and <code>&lt;iterations&gt;</code>'s, which applies the link N times"], ["<link>¡", "a link of the same arity as <code>&lt;link&gt;</code>, which applies the link N times, where N is the last command line argument, or if none are present, the next line of input from STDIN"]]
  },
  {
    "symbol": "¿",
    "id": "while-loop",
    "name": "While Loop",
    "arity": -1,
    "keywords": ["while", "loop"],
    "tags": ["boolean"],
    "tagline": "Repeat a link while a condition is true.",
    "description": "If the link is dyadic, after the first iteration, the previous result is the left argument and the result before that (the left argument is the initial result) is the right argument. This returns the result that makes the condition false, not the last truthy result.",
    "syntax": [["<link><condition>¿", "a link whose arity is the maximum of <code>&lt;link&gt;</code>'s and <code>&lt;condition&gt;</code>'s, which applies the link as long as the condition is true"]]
  },
  {
    "symbol": "/",
    "id": "reduce",
    "name": "Reduce",
    "arity": 1,
    "keywords": ["reduce", "scan", "nwise"],
    "tags": ["array"],
    "tagline": "Reduce or n-wise reduce a list.",
    "description": "If a nilad appears right before <code>/</code>, this does n-wise reduce. For positive <code>n</code>, split the list into chunks of length <code>n</code> (identical to <a href='/atoms/split-length'><code>s</code> (Split (Length))</a>) and reduce each sublist. For negative <code>n</code>, instead of reducing each sublist, slice and remove chunks of length <code>-n</code>. For example, <code>5R ;-2/</code> returns <code>[[3, 4, 5], [1, 2, 5], [1, 2, 3, 4]]</code> - in the first list, <code>[1, 2]</code> is removed, in the second list, <code>[3, 4]</code> is removed, and in the last list, <code>[5]</code> is removed.<br /><br />To a reduce a list, begin with the first element, and then for each subsequent element, apply the link to the current accumulator and the incoming value. <code>a,b,c,... ×/</code> is equivalent to <code>a × b × c × ...</code>. The link must be a dyad; if you want to apply a monad to the two elements, you can use the idiom <code>,F¥</code> for some monad <code>F</code>, which first pairs the elements and then calls <code>F</code> on the result.",
    "syntax": [["<dyad>/", "reduce"], ["<dyad><nilad>/", "n-wise reduce"]]
  },
  {
    "symbol": "ƒ",
    "id": "reduce-starting",
    "name": "Reduce With Starting Value",
    "arity": 2,
    "keywords": ["reduce", "scan", "starting", "value", "initial", "nwise"],
    "tags": ["array"],
    "tagline": "Reduce or n-wise reduce a list starting at the right argument.",
    "description": "If a nilad appears right before <code>ƒ</code>, this does n-wise reduce. For positive <code>n</code>, split the list into chunks of length <code>n</code> (identical to <a href='/atoms/split-length'><code>s</code> (Split (Length))</a>) and reduce each sublist. For negative <code>n</code>, instead of reducing each sublist, slice and remove chunks of length <code>-n</code>. For example, <code>5R ;-2ƒ0</code> returns <code>[[0, 3, 4, 5], [0, 1, 2, 5], [0, 1, 2, 3, 4]]</code> - in the first list, <code>[1, 2]</code> is removed, in the second list, <code>[3, 4]</code> is removed, and in the last list, <code>[5]</code> is removed.<br /><br />To a reduce a list, begin with the right argument, and then for each element, apply the link to the current accumulator and the incoming value. <code>a,b,c,... ×ƒ y</code> is equivalent to <code>y × a × b × c × ...</code>. The link must be a dyad; if you want to apply a monad to the two elements, you can use the idiom <code>,F¥</code> for some monad <code>F</code>, which first pairs the elements and then calls <code>F</code> on the result.",
    "syntax": [["<dyad>ƒ", "reduce"], ["<dyad><nilad>ƒ", "n-wise reduce"]]
  },
  {
    "symbol": "\\",
    "id": "cumulative-reduce",
    "name": "Cumulative Reduce",
    "arity": 1,
    "keywords": ["cumulative", "reduce", "scan", "nwise", "overlapping"],
    "tags": ["array"],
    "tagline": "Cumulative reduce or n-wise overlapping (simple) reduce.",
    "description": "If a nilad appears right before <code>\\</code>, this does n-wise overlapping reduce. For positive <code>n</code>, split the list into overlapping chunks of length <code>n</code> (identical to <a href='/atoms/split-length-overlapping'><code>ṡ</code> (Split (Length, Overlapping))</a>) and reduce each sublist. For negative <code>n</code>, instead of reducing each sublist, slice and remove chunks of length <code>-n</code>. For example, <code>5R ;-2\\</code> returns <code>[[3, 4, 5], [1, 4, 5], [1, 2, 5], [1, 2, 3]]</code> - in the first list, <code>[1, 2]</code> is removed, in the second list, <code>[2, 3]</code> is removed, etc. Note that it does <em>not</em> cumulatively reduce each slice - if you want to do that, you need to manually slice the list with <code>ṡ</code> and cumulatively reduce each sublist.<br /><br />To a reduce a list, begin with the right argument, and then for each element, apply the link to the current accumulator and the incoming value. <code>a,b,c,... \\</code> is equivalent to <code>[a, a × b, a × b × c, ...]</code>. The link must be a dyad; if you want to apply a monad to the two elements, you can use the idiom <code>,F¥</code> for some monad <code>F</code>, which first pairs the elements and then calls <code>F</code> on the result.",
    "syntax": [["<dyad>\\", "cumulative reduce"], ["<dyad><nilad>\\", "n-wise overlapping reduce"]]
  },
  {
    "symbol": "¤",
    "id": "nilad-combinator",
    "name": "Nilad Followed By Links As A Nilad",
    "arity": 0,
    "keywords": ["nilad", "followed", "following", "multiple", "links", "combined", "combinator"],
    "tags": ["combinator"],
    "tagline": "Combine a nilad followed by at least one link into one nilad. Matches the shortest valid sequence.",
    "description": "",
    "syntax": [["<nilad><links...>¤", "combine the nilad followed by links into one nilad"]]
  },
  {
    "symbol": "$",
    "id": "combine-two-monad",
    "name": "Last Two As Monad",
    "arity": 1,
    "keywords": ["combine", "last", "two", "links", "together", "monad"],
    "tags": ["combinator"],
    "tagline": "Combine two links (that aren't part of an <a href='/beginners#leading-constant-chains'>LCC</a>) into one monad.",
    "description": "Scanning backwards, if the chain starting at that point is not an LCC, increment a counter. Once the counter reaches two, return those links combined into a monad.",
    "syntax": [["<link><link>$", "combine links into one monad"]]
  },
  {
    "symbol": "Ɗ",
    "id": "combine-three-monad",
    "name": "Last Three As Monad",
    "arity": 1,
    "keywords": ["combine", "last", "three", "links", "together", "monad"],
    "tags": ["combinator"],
    "tagline": "Combine three links (that aren't part of an <a href='/beginners#leading-constant-chains'>LCC</a>) into one monad.",
    "description": "Scanning backwards, if the chain starting at that point is not an LCC, increment a counter. Once the counter reaches three, return those links combined into a monad.",
    "syntax": [["<link><link><link>Ɗ", "combine links into one monad"]]
  },
  {
    "symbol": "Ʋ",
    "id": "combine-four-monad",
    "name": "Last Four As Monad",
    "arity": 1,
    "keywords": ["combine", "last", "four", "links", "together", "monad"],
    "tags": ["combinator"],
    "tagline": "Combine four links (that aren't part of an <a href='/beginners#leading-constant-chains'>LCC</a>) into one monad.",
    "description": "Scanning backwards, if the chain starting at that point is not an LCC, increment a counter. Once the counter reaches four, return those links combined into a monad.",
    "syntax": [["<link><link><link><link>Ʋ", "combine links into one monad"]]
  },
  {
    "symbol": "¥",
    "id": "combine-two-dyad",
    "name": "Last Two As Dyad",
    "arity": 2,
    "keywords": ["combine", "last", "two", "links", "together", "dyad"],
    "tags": ["combinator"],
    "tagline": "Combine two links (that aren't part of an <a href='/beginners#leading-constant-chains'>LCC</a>) into one dyad.",
    "description": "Scanning backwards, if the chain starting at that point is not an LCC, increment a counter. Once the counter reaches two, return those links combined into a dyad.",
    "syntax": [["<link><link>¥", "combine links into one dyad"]]
  },
  {
    "symbol": "ɗ",
    "id": "combine-three-dyad",
    "name": "Last Three As Dyad",
    "arity": 2,
    "keywords": ["combine", "last", "three", "links", "together", "dyad"],
    "tags": ["combinator"],
    "tagline": "Combine three links (that aren't part of an <a href='/beginners#leading-constant-chains'>LCC</a>) into one dyad.",
    "description": "Scanning backwards, if the chain starting at that point is not an LCC, increment a counter. Once the counter reaches three, return those links combined into a dyad.",
    "syntax": [["<link><link><link>ɗ", "combine links into one dyad"]]
  },
  {
    "symbol": "ʋ",
    "id": "combine-four-dyad",
    "name": "Last Four As Dyad",
    "arity": 2,
    "keywords": ["combine", "last", "four", "links", "together", "dyad"],
    "tags": ["combinator"],
    "tagline": "Combine four links (that aren't part of an <a href='/beginners#leading-constant-chains'>LCC</a>) into one dyad.",
    "description": "Scanning backwards, if the chain starting at that point is not an LCC, increment a counter. Once the counter reaches four, return those links combined into a dyad.",
    "syntax": [["<link><link><link><link>ʋ", "combine links into one dyad"]]
  },
  {
    "symbol": "#",
    "id": "nfind",
    "name": "nfind",
    "arity": -1,
    "keywords": ["nfind", "first", "n", "integers"],
    "tags": ["array"],
    "tagline": "nfind; get the first N integers satisfying some condition.",
    "description": "The arity of the resulting link is the maximum of its consumed links' arities. The initial value is the left argument if the link is at least monadic, and <code>0</code> otherwise. Then, starting from that value, if it satisfies the specified condition, add it to a list. Then, increment the value. Once N matches have been found, return the array of matches.",
    "syntax": [["<link><count>#", "collect the first <code>&lt;count&gt;</code> integers that match <code>&lt;link&gt;</code>"], ["<link>#", "collect the first N integers that match <code>&lt;link&gt;</code>, where N is the last command line argument, or if none are present, the next line of input from STDIN"]]
  },
  {
    "symbol": "?",
    "id": "ternary-if",
    "name": "Ternary If",
    "arity": -1,
    "keywords": ["ternary", "if", "else", "ifelse", "conditional", "branch"],
    "tags": ["boolean"],
    "tagline": "Ternary If; call a link depending on the result of a conditional. The resulting link's arity is the maximum of its consumed links' arities.",
    "description": "",
    "syntax": [["<if-link><else-link><condition>?", "if the result of calling <code>&lt;condition&gt;</code> is truthy, call <code>&lt;if-link&gt;</code>; otherwise, call <code>&lt;else-link&gt;</code>"]]
  },
  {
    "symbol": "Ƒ",
    "id": "invariant",
    "name": "Invariant",
    "arity": -2,
    "keywords": ["check", "left", "argument", "equal", "result", "invariant", "same", "under"],
    "tags": ["boolean", "hyper"],
    "tagline": "Check if the left argument is equal to the result.",
    "description": "For nilads, <code>0Ƒ</code> is equivalent to <code>⁼0$</code>. For monads, <code>AƑ</code> is equivalent to <code>⁼A$</code>. For dyads, <code>×Ƒ</code> is equivalent to <code>⁼×¥</code>.",
    "syntax": [["<nilad>Ƒ", "a monadic link that checks if the left argument is equal to <code>&lt;nilad&gt;</code>"], ["<link>Ƒ", "a link of the same arity as <code>&lt;link&gt;</code> that checks if the left argument is equal to the result of the link"]]
  },
  {
    "symbol": "⁺",
    "id": "duplicate",
    "name": "Duplicate",
    "arity": -1,
    "keywords": ["duplicate", "copy", "repeat", "twice", "nayeon", "jeongyeon", "momo", "sana", "jihyo", "mina", "dahyun", "chaeyoung", "tzuyu"],
    "tags": [],
    "tagline": "Duplicate the previous link. Does not combine them together, so <code>F⁺€</code> will call <code>F</code> and then <code>F</code> on each, not <code>FF</code> on each.",
    "description": "",
    "syntax": [["<link>⁺", "push another copy of the link"]]
  },
  {
    "symbol": "@",
    "id": "swap",
    "name": "Swap / Selfie",
    "arity": 2,
    "keywords": ["swap", "switch", "reverse", "order", "left", "right", "arguments", "selfie"],
    "tags": ["hyper"],
    "tagline": "Swap the arguments of a dyad.",
    "description": "",
    "syntax": [["<dyad>@", "swap the arguments; <code>x ÷@ y</code> is equivalent to <code>y ÷ x</code>"]]
  },
  {
    "symbol": "`",
    "id": "reflect-arguments",
    "name": "Reflect Arguments",
    "arity": 1,
    "keywords": ["monad", "dyad", "repeat", "reflect", "selfie"],
    "tags": ["hyper"],
    "tagline": "Turn a dyad into a monad that calls the underlying link with the left argument on both sides.",
    "description": "",
    "syntax": [["<dyad>`", "reflect arguments; <code>x ÷`</code> is equivalent to <code>x ÷ x</code>"]]
  },
  {
    "symbol": "\"",
    "id": "vectorize",
    "name": "Vectorize / Zip With",
    "arity": 2,
    "keywords": ["vectorize", "zipwith", "ziptogether"],
    "tags": ["hyper", "vectorize"],
    "tagline": "<a href='/beginners#vectorization'>Vectorize</a> a dyad by one level (call between pairs of the left and right arguments).",
    "description": "<code>1 ÷\" 1,2,3</code> is <code>[1 ÷ 1, 1 ÷ 2, 1 ÷ 3]</code>. <code>1,2,3 ÷\" 1<code> is <code>[1 ÷ 1, 2 ÷ 1, 3 ÷ 1]</code>. <code>1,2,3 ÷ 4,5,6</code> is <code>[1 ÷ 4, 2 ÷ 5, 3 ÷ 6]</code>. If one side is longer, trailing arguments are appended, so <code>1,2 ÷ 3,4,5</code> is <code>[1 ÷ 3, 2 ÷ 4, 5]</code>. If both sides are flat values, this quick has no effect.",
    "syntax": [["<dyad>\"", "vectorize by one level"]]
  },
  {
    "symbol": "'",
    "id": "flat",
    "name": "Flat / Spawn",
    "arity": -1,
    "keywords": ["flat", "spawn", "unvectorize", "non", "do", "not", "dont"],
    "tags": ["hyper"],
    "tagline": "Flat / Spawn; don't vectorize on the left argument.",
    "description": "For monads, flat; that is, don't vectorize. For example, <code>U'</code> is equivalent to <code>Ṛ</code>. For dyads, spawn; that is, don't vectorize on the left argument. For example, rather than returning <code>[5, 7, 9]</code> like vectorization normally would, <code>1,2,3 +' 4,5,6</code> will return <code>[[5, 6, 7], [6, 7, 8], [7, 8, 9]]</code> (note that after reaching the last layer, <code>+</code> will still vectorize anyway). <code>1,0,2 ×' 3</code> returns <code>[1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2]</code>, but be careful as this behavior is not consistent; <code>1,0,2 ×' 4,5</code> returns <code>[[4, 0, 8], [5, 0, 10]]</code>.",
    "syntax": [["<monad>'", "flat"], ["<dyad>'", "spawn"]]
  },
  {
    "symbol": "þ",
    "id": "outer-product",
    "name": "Outer Product / Table",
    "arity": 2,
    "keywords": ["outer", "product", "table"],
    "tags": ["hyper", "array", "matrix"],
    "tagline": "Outer Product / Table; equivalent to <a href='/quicks/each'><code>€</code> (Each)</a> followed by <a href='/quicks/each-right'><code>Ɱ</code> (Each (Right))</a>.",
    "description": "Returns a matrix where the element at row <code>i</code> and column <code>y</code> is the result of calling the link on the <code>j</code><sup>th</sup> element of the left argument and the <code>i</code><sup>th</sup> element of the right argument.",
    "syntax": [["<dyad>þ", "outer product / table"]]
  },
  {
    "symbol": "{",
    "id": "to-dyad",
    "name": "Monad To Dyad (Left)",
    "arity": 2,
    "keywords": ["monad", "dyad", "convert", "uses", "left", "argument"],
    "tags": ["hyper"],
    "tagline": "Turn a monad into a dyad that calls the underlying monad on its left argument and ignores its right argument.",
    "description": "<code>x F{ y</code> is equivalent to <code>x F</code>.",
    "syntax": [["<monad>{", "monad to dyad, using the left argument"]]
  },
  {
    "symbol": "}",
    "id": "to-dyad-inverted",
    "name": "Monad To Dyad (Right)",
    "arity": 2,
    "keywords": ["monad", "dyad", "convert", "uses", "right", "argument"],
    "tags": ["hyper"],
    "tagline": "Turn a monad into a dyad that calls the underlying monad on its right argument and ignores its left argument.",
    "description": "<code>x F} y</code> is equivalent to <code>y F</code>.",
    "syntax": [["<monad>}", "monad to dyad, using the right argument"]]
  },
  {
    "symbol": "€",
    "id": "each",
    "name": "Each",
    "arity": -1,
    "keywords": ["foreach", "left", "map", "apply", "loop"],
    "tags": ["hyper", "array"],
    "tagline": "Map the link over its left argument, automatically casting numbers to a range.",
    "description": "If given a nilad, this quick returns a monad which just calls the nilad once per element and produces a list of the results. If given a dyad, the resulting link is also a dyad, and it will loop over the left argument and apply with the same right argument each time.",
    "syntax": [["<link>€", "each (over left argument)"]]
  },
  {
    "symbol": "Þ",
    "id": "sort-by",
    "name": "Sort By Key Function",
    "arity": -1,
    "keywords": ["sort", "by", "over", "key", "function"],
    "tags": ["hyper", "array"],
    "tagline": "Stable sort by some key function.",
    "description": "If given a nilad, this will produce a nilad; however, it errors when you actually try to call it. If given a dyad, the resulting link is also a dyad, and it will apply the key function to each element in the left argument with the same right argument each time. ",
    "syntax": [["<monad/dyad>Þ", "sort by key function"]]
  },
  {
    "symbol": "Ɲ",
    "id": "neighbors",
    "name": "Apply To Neighbors",
    "arity": 1,
    "keywords": ["neighbors", "neighbours", "pairs", "adjacent", "elements", "apply"],
    "tags": ["array"],
    "tagline": "Apply a dyadic link or monadic chain to each pair of adjacent elements.",
    "description": "",
    "syntax": [["<dyad>Ɲ", "apply the dyad between each pair"], ["<monad>Ɲ", "apply the monad to each pair"], ["<link><nilad>Ɲ", "apply the chain to each pair"]]
  },
  {
    "symbol": "Ƥ",
    "id": "prefixes",
    "name": "Prefixes",
    "arity": 1,
    "keywords": ["prefixes", "overlapping", "infixes", "outfixes", "slices"],
    "tags": ["array"],
    "tagline": "Apply a link to prefixes or to overlapping infixes / outfixes.",
    "description": "If the link right before <code>Ƥ</code> is a nilad, apply to overlapping infixes / outfixes of size <code>n</code>. For positive <code>n</code>, split the list into overlapping chunks of length <code>n</code> (identical to <a href='/atoms/split-length-overlapping'><code>ṡ</code> (Split (Length, Overlapping))</a>) and apply to each sublist. For negative <code>n</code>, instead of reducing each sublist, slice and remove chunks of length <code>-n</code>. For example, <code>5R ¹-2Ƥ</code> returns <code>[[3, 4, 5], [1, 4, 5], [1, 2, 5], [1, 2, 3]]</code> - in the first list, <code>[1, 2]</code> is removed, in the second list, <code>[2, 3]</code> is removed, etc.<br /><br />Otherwise, simply apply the link to each prefix. <code>a,b,c,... SƤ</code> is equivalent to <code>[[a] S, [a, b] S, [a, b, c] S, ...]</code>.",
    "syntax": [["<monad>Ƥ", "apply to prefixes"], ["<monad><nilad>Ƥ", "apply to overlapping in/out-fixes"]]
  },
  {
    "symbol": "ƙ",
    "id": "key-map",
    "name": "Map Over Groups",
    "arity": 2,
    "keywords": ["key", "map", "over", "groups", "formed", "identical", "equality", "elements", "left", "right", "arguments", "list"],
    "tags": ["array"],
    "tagline": "Group elements of the right argument where the corresponding elements in the left argument are equal, then map a link over each group.",
    "description": "Try this out with <code>¹ƙ</code> on a few examples to get the hang of it. Essentially, for each index in the right argument, if the element at that index in the left argument is the same as that for another index, the two corresponding elements are grouped together. Groups appear in order of their first occurrence in the right argument, and if the left argument is shorter, the trailing elements are grouped together. Finally, the link is applied to each group.<br /><br />For example, consider <code>1,2,1,2,2 Sƙ 1,2,3,4,5,6,7</code>. Using the left argument as a key, indices <code>[1, 3]</code> and <code>[2, 4, 5]</code> (as well as the trailing indices <code>[6, 7]</code>) should be grouped. Thus, the right argument is grouped into <code>[[1, 3], [2, 4, 5], [6, 7]]</code>. Finally, <a href='/atoms/sum'><code>S</code> (Sum)</a> is applied to each group, so the result is <code>[4, 11, 13]</code>.",
    "syntax": [["<monad>ƙ", "a dyadic link that groups the right argument by the left argument as a key, and then applies the monad to each group"]]
  },
  {
    "symbol": "ɼ",
    "id": "apply-to-register",
    "name": "Apply To Register",
    "arity": -2,
    "keywords": ["apply", "register", "link"],
    "tags": ["register", "hyper"],
    "tagline": "Apply the link to the register, copy to the register, and return the result.",
    "description": "",
    "syntax": [["<nilad/monad>ɼ", "a niladic link that applies the monad to the register / evaluates the nilad and saves + returns the result to the register"], ["<dyad>ɼ", "a monadic link that applies the dyad to the register on the left and the left argument on the right, then saves + returns the result to the register"]]
  },
  {
    "symbol": "ƭ",
    "id": "tie",
    "name": "Tie",
    "arity": -2,
    "keywords": ["tie", "multiple", "links", "cycle"],
    "tags": [],
    "tagline": "Tie multiple links together; cycle through them each time the link is called.",
    "description": "The resulting link's arity is the maximum of its combined links' arities (or if all are nilads, the resulting link is monadic). Each time the link is evaluated anywhere, call the current sub-link, then cycle to the next sub-link. For example, <code>10R HḤƭ€</code> returns <code>[0.5, 4, 1.5, 8, 2.5, 12, 3.5, 16, 4.5, 20]</code>.",
    "syntax": [["<links...><nilad>ƭ", "tie N links"], ["<link><link>ƭ", "tie two links"]]
  },
  {
    "symbol": "Ɱ",
    "id": "each-right",
    "name": "Each (Right)",
    "arity": 2,
    "keywords": ["foreach", "right", "map", "apply", "loop"],
    "tags": ["hyper", "array"],
    "tagline": "Map the link over its right argument, automatically casting numbers to a range.",
    "description": "If given a dyad, the resulting link is a dyad, and it will loop over the right argument and apply with the same left argument each time. Otherwise, calling the resulting link will error.",
    "syntax": [["<dyad>Ɱ", "each (over right argument)"]]
  },
  {
    "symbol": "Ð¡",
    "id": "ntimes-collect",
    "name": "Repeat N Times (Collect)",
    "arity": -1,
    "keywords": ["repeat", "ntimes", "loop", "collect", "keep", "intermediate"],
    "tags": ["number"],
    "tagline": "Apply a link N times, collecting intermediate results (like <a href='/quicks/ntimes'><code>¡</code> (N Times)</a>).",
    "description": "If the link is dyadic, after the first iteration, the previous result is the left argument and the result before that (the left argument is the initial result) is the right argument. See <a href='/quicks/ntimes'><code>¡</code> (N Times)</a> for more details and examples.",
    "syntax": [["<link><iterations>Ð¡", "a link whose arity is the maximum of <code>&lt;link&gt;</code>'s and <code>&lt;iterations&gt;</code>'s, which applies the link N times"], ["<link>Ð¡", "a link of the same arity as <code>&lt;link&gt;</code>, which applies the link N times, where N is the last command line argument, or if none are present, the next line of input from STDIN"]]
  },
  {
    "symbol": "Ð¿",
    "id": "while-loop-collect",
    "name": "While Loop (Collect)",
    "arity": -1,
    "keywords": ["while", "loop", "collect", "keep", "intermediate"],
    "tags": ["boolean"],
    "tagline": "Repeat a link while a condition is true, collecting intermediate results (like <a href='/quicks/while-loop'><code>¿</code> (While Loop)</a>).",
    "description": "If the link is dyadic, after the first iteration, the previous result is the left argument and the result before that (the left argument is the initial result) is the right argument. The result includes the value that makes the condition false.",
    "syntax": [["<link><condition>Ð¿", "a link whose arity is the maximum of <code>&lt;link&gt;</code>'s and <code>&lt;condition&gt;</code>'s, which applies the link as long as the condition is true"]]
  },
  {
    "symbol": "ÐƤ",
    "id": "suffixes",
    "name": "Suffixes",
    "arity": 1,
    "keywords": ["suffixes", "not", "nonoverlapping", "infixes", "outfixes", "slices"],
    "tags": ["array"],
    "tagline": "Apply a link to suffixes or to non-overlapping infixes / outfixes.",
    "description": "If the link right before <code>ÐƤ</code> is a nilad, apply to non-overlapping infixes / outfixes of size <code>n</code>. For positive <code>n</code>, split the list into overlapping chunks of length <code>n</code> (identical to <a href='/atoms/split-length'><code>s</code> (Split (Length))</a>) and apply to each sublist. For negative <code>n</code>, instead of reducing each sublist, slice and remove chunks of length <code>-n</code>. For example, <code>5R ¹-2ÐƤ</code> returns <code>[[3, 4, 5], [1, 2, 5], [1, 2, 3, 4]]</code> - in the first list, <code>[1, 2]</code> is removed, in the second list, <code>[3, 4]</code> is removed, and in the last list, <code>[5]</code> is removed.<br /><br />Otherwise, simply apply the link to each suffix. <code>a,b,c,... SÐƤ</code> is equivalent to <code>[[a, b, c, ...] S, [b, c, ...] S, [c, ...] S, ...]</code>.",
    "syntax": [["<monad>ÐƤ", "apply to suffixes"], ["<monad><nilad>ÐƤ", "apply to non-overlapping in/out-fixes"]]
  },
  {
    "symbol": "Ƈ",
    "id": "filter-by",
    "name": "Filter",
    "arity": -1,
    "keywords": ["filter", "by", "over", "keep"],
    "tags": ["hyper", "array", "boolean"],
    "tagline": "Filter; keep items that return a truthy value when the condition is called.",
    "description": "If the link is dyadic, the resulting link is a dyad which applies to each element of the left argument with the same right argument each time to determine which items to keep. If the link is niladic, this will error. This is an alias for <code>Ðf</code>, which is still available for backwards compatibility.",
    "syntax": [["<monad/dyad>Ƈ", "filter by a condition"]]
  },
  {
    "symbol": "Ðḟ",
    "id": "filter-against",
    "name": "Filter Out",
    "arity": -1,
    "keywords": ["filter", "against", "out", "remove", "discard", "remove", "delete"],
    "tags": ["hyper", "array", "boolean"],
    "tagline": "Filter; discard items that return a truthy value when the condition is called.",
    "description": "If the link is dyadic, the resulting link is a dyad which applies to each element of the left argument with the same right argument each time to determine which items to discard. If the link is niladic, this will error. This is an alias for <code>Ðf</code>, which is still available for backwards compatibility.",
    "syntax": [["<monad/dyad>Ðḟ", "filter against a condition"]]
  },
  {
    "symbol": "ÐL",
    "id": "loop-until-loop",
    "name": "Repeat Until No Longer Unique",
    "arity": -1,
    "keywords": ["repeat", "loop", "until", "same", "repeat", "not", "longer", "unique"],
    "tags": ["hyper"],
    "tagline": "Repeat a link until the result is no longer unique, returning the last unique result.",
    "description": "If the link is dyadic, after the first iteration, the previous result is the left argument and the result before that (the left argument is the initial result) is the right argument. No-op for niladic links. For example, to evaluate <code>1 +%10ɗ ÐL 1</code>, we begin with <code>1</code>. The next value is <code>1 + 1</code>, then <code>2 + 1</code>, then <code>3 + 2</code>, then <code>5 + 3</code>, then <code>8 + 5</code> (which evaluates to <code>3</code> because of the <code>% 10</code>). This result is not unique, so the result is <code>8</code>.",
    "syntax": [["<link>ÐL", "loop until results are no longer unique"]]
  },
  {
    "symbol": "ÐĿ",
    "id": "loop-until-loop-all",
    "name": "Repeat Until No Longer Unique (Collect All)",
    "arity": -1,
    "keywords": ["repeat", "loop", "until", "same", "repeat", "not", "longer", "unique", "all"],
    "tags": ["hyper", "array"],
    "tagline": "Repeat a link until the result is no longer unique, returning all unique results.",
    "description": "If the link is dyadic, after the first iteration, the previous result is the left argument and the result before that (the left argument is the initial result) is the right argument. For niladic links, it will return <code>[None, z]</code> as a result of undefined behavior. For example, to evaluate <code>1 +%10ɗ ÐL 1</code>, we begin with <code>1</code>. The next value is <code>1 + 1</code>, then <code>2 + 1</code>, then <code>3 + 2</code>, then <code>5 + 3</code>, then <code>8 + 5</code> (which evaluates to <code>3</code> because of the <code>% 10</code>). This result is not unique, so the result is <code>[1, 2, 3, 5, 8]</code>.",
    "syntax": [["<link>ÐĿ", "loop until results are no longer unique"]]
  },
  {
    "symbol": "ÐḶ",
    "id": "loop-until-loop-loop",
    "name": "Repeat Until No Longer Unique (Collect Loop)",
    "arity": -1,
    "keywords": ["repeat", "loop", "until", "same", "repeat", "not", "longer", "unique", "all"],
    "tags": ["hyper", "array"],
    "tagline": "Repeat a link until the result is no longer unique, returning results in the loop.",
    "description": "If the link is dyadic, after the first iteration, the previous result is the left argument and the result before that (the left argument is the initial result) is the right argument. For niladic links, it will return <code>[None, z]</code> as a result of undefined behavior. For example, to evaluate <code>1 +%10ɗ ÐḶ 1</code>, we begin with <code>1</code>. The next value is <code>1 + 1</code>, then <code>2 + 1</code>, then <code>3 + 2</code>, then <code>5 + 3</code>, then <code>8 + 5</code> (which evaluates to <code>3</code> because of the <code>% 10</code>). This result is not unique, so all elements between the repeated element and the final result are collected, and the result is <code>[3, 5, 8]</code>.",
    "syntax": [["<link>ÐḶ", "loop until results are no longer unique"]]
  },
  {
    "symbol": "Ƭ",
    "id": "loop-until-loop-all-fixed-right",
    "name": "Repeat Until No Longer Unique (Collect All, Fixed Right Argument)",
    "arity": -1,
    "keywords": ["repeat", "loop", "until", "same", "repeat", "not", "longer", "unique", "all", "fixed"],
    "tags": ["hyper", "array"],
    "tagline": "Repeat a link until the result is no longer unique, returning all unique results. The right argument is fixed if present.",
    "description": "Unlike its counterparts, <a href='/quicks/loop-until-loop'><code>ÐL</code> (Repeat Until No Longer Unique)</a>, <a href='/quicks/loop-until-loop-all'><code>ÐĿ</code> (Repeat Until No Longer Unique (Collect All))</a>, and <a href='/quicks/loop-until-loop-loop'><code>ÐḶ</code> (Repeat Until No Longer Unique (Collect Loop))</a>, if the link is dyadic, the right argument remains fixed. For niladic links, it will return <code>[None, z]</code> as a result of undefined behavior. For example, to evaluate <code>1 +%10ɗ Ƭ 1</code>, we begin with <code>1</code>. The next value is <code>1 + 1</code>, then <code>2 + 1</code>, then <code>3 + 1</code>, then <code>4 + 1</code>, etc. Eventually, we reach <code>0 + 1</code> (because of the <code>% 10</code), which is not unique, so the result is <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 0]</code>.",
    "syntax": [["<link>Ƭ", "loop until results are no longer unique"]]
  },
  {
    "symbol": "ÐṂ",
    "id": "minimal-link-value",
    "name": "Elements With Minimal Link Value",
    "arity": -1,
    "keywords": ["elements", "with", "minimal", "link", "value"],
    "tags": ["hyper", "array"],
    "tagline": "Keep elements whose link results are minimal across the list; i.e., <code>[x for x in z if link(z) == min(map(link, z))]</code>.",
    "description": "",
    "syntax": [["<link>ÐṂ", "keep minimal elements"]]
  },
  {
    "symbol": "ÐṀ",
    "id": "maximal-link-value",
    "name": "Elements With Maximal Link Value",
    "arity": -1,
    "keywords": ["elements", "with", "maximal", "link", "value"],
    "tags": ["hyper", "array"],
    "tagline": "Keep elements whose link results are maximal across the list; i.e., <code>[x for x in z if link(z) == max(map(link, z))]</code>.",
    "description": "",
    "syntax": [["<link>ÐṀ", "keep maximal elements"]]
  },
  {
    "symbol": "Ðe",
    "id": "apply-to-even",
    "name": "Apply To Even Indices",
    "arity": -1,
    "keywords": ["apply", "even", "indices", "indexes"],
    "tags": ["hyper", "array", "number"],
    "tagline": "Apply a link to even indices. This description is actually misleading; see <a href='/quicks/apply-at-indices'><code>¦</code> (Apply At Indices)</a> for details.",
    "description": "",
    "syntax": [["<link>Ðe", "apply the link to even indices"]]
  },
  {
    "symbol": "Ðo",
    "id": "apply-to-odd",
    "name": "Apply To Odd Indices",
    "arity": -1,
    "keywords": ["apply", "odd", "indices", "indexes"],
    "tags": ["hyper", "array", "number"],
    "tagline": "Apply a link to odd indices. This description is actually misleading; see <a href='/quicks/apply-at-indices'><code>¦</code> (Apply At Indices)</a> for details.",
    "description": "",
    "syntax": [["<link>Ðo", "apply the link to odd indices"]]
  }
]
