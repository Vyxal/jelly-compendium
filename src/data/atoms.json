[
  {
    "symbol": "®",
    "id": "retrieve-register",
    "name": "Restore Register",
    "arity": 0,
    "keywords": ["restore", "retrieve", "register"],
    "tags": ["register"],
    "tagline": "Restore the value of the <a href='/misc/register'>register</a> (initially zero).",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "³",
    "id": "third-cla",
    "name": "First Input / Third Argument",
    "arity": 0,
    "keywords": ["1st", "3rd", "first", "third", "input", "command", "line", "argument", "100"],
    "tags": ["arguments"],
    "tagline": "Get the first input (third command line argument), or <code>100</code>.",
    "description": "If the program is run with at least one input (three arguments, ignoring the flags and the file/code), return the value of the first input. Otherwise, return <code>100</code>.",
    "synonyms": []
  },
  {
    "symbol": "⁴",
    "id": "fourth-cla",
    "name": "Second Input / Fourth Argument",
    "arity": 0,
    "keywords": ["2nd", "4th", "second", "fourth", "input", "command", "line", "argument", "16"],
    "tags": ["arguments"],
    "tagline": "Get the second input (fourth command line argument), or <code>16</code>.",
    "description": "If the program is run with at least two inputs (four arguments, ignoring the flags and the file/code), return the value of the second input. Otherwise, return <code>16</code>.",
    "synonyms": []
  },
  {
    "symbol": "⁵",
    "id": "fifth-cla",
    "name": "Third Input / Fifth Argument",
    "arity": 0,
    "keywords": ["3rd", "5th", "third", "fifth", "input", "command", "line", "argument", "10"],
    "tags": ["arguments"],
    "tagline": "Get the third input (fifth command line argument), or <code>10</code>.",
    "description": "If the program is run with at least three inputs (five arguments, ignoring the flags and the file/code), return the value of the third input. Otherwise, return <code>10</code>.",
    "synonyms": []
  },
  {
    "symbol": "⁶",
    "id": "sixth-cla",
    "name": "Fourth Input / Sixth Argument",
    "arity": 0,
    "keywords": ["4th", "6th", "fourth", "sixth", "input", "command", "line", "argument", "space"],
    "tags": ["arguments"],
    "tagline": "Get the first input (third command line argument), or <code>\" \"</code>.",
    "description": "If the program is run with at least four inputs (six arguments, ignoring the flags and the file/code), return the value of the fourth input. Otherwise, return <code>\" \"</code>.",
    "synonyms": []
  },
  {
    "symbol": "⁷",
    "id": "seventh-cla",
    "name": "Fifth Input / Seventh Argument",
    "arity": 0,
    "keywords": ["5th", "7th", "fifth", "seventh", "input", "command", "line", "argument", "100"],
    "tags": ["arguments"],
    "tagline": "Get the fifth input (seventh command line argument), or <code>\"\\n\"</code>.",
    "description": "If the program is run with at least five inputs (seven arguments, ignoring the flags and the file/code), return the value of the fifth input. Otherwise, return <code>\"\\n\"</code>.",
    "synonyms": []
  },
  {
    "symbol": "⁸",
    "id": "chain-left",
    "name": "Chain Left Argument",
    "arity": 0,
    "keywords": ["link", "chain", "left", "argument", "empty", "list"],
    "tags": ["arguments"],
    "tagline": "Get the left argument of the link/chain, or <code>[]</code>.",
    "description": "If the current chain is monadic or dyadic, return the value of the left argument. Otherwise, return <code>[]</code>.",
    "synonyms": []
  },
  {
    "symbol": "⁹",
    "id": "chain-right",
    "name": "Chain Right Argument",
    "arity": 0,
    "keywords": ["link", "chain", "right", "argument", "256"],
    "tags": ["arguments"],
    "tagline": "Get the right argument of the link/chain, or <code>256</code>.",
    "description": "If the current chain is dyadic, return the value of the right argument. Otherwise, return <code>256</code>.",
    "synonyms": []
  },
  {
    "symbol": "Ɠ",
    "id": "eval-stdin",
    "name": "Evaluate STDIN",
    "arity": 0,
    "keywords": ["evaluate", "read", "line", "standard", "stdin", "input"],
    "tags": ["stdio"],
    "tagline": "Read and evaluate a single line from STDIN.",
    "description": "Read a line from standard input and evaluate it as Python code. Note that reading from STDIN is not usually as golfy or idiomatic as using the arguments tacitly; however, in certain circumstances, such as relying on the link or program being niladic for the alternative meanings of the argument nilads, it can actually save some bytes.",
    "synonyms": ["ɠŒV¤"]
  },
  {
    "symbol": "ƈ",
    "id": "char-stdin",
    "name": "Read Character from STDIN",
    "arity": 0,
    "keywords": ["read", "character", "standard", "stdin", "input"],
    "tags": ["stdio"],
    "tagline": "Read a single character from STDIN.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ɠ",
    "id": "line-stdin",
    "name": "Read Line from STDIN",
    "arity": 0,
    "keywords": ["read", "line", "standard", "stdin", "input"],
    "tags": ["stdio"],
    "tagline": "Read a single line from STDIN.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "¬",
    "id": "logical-not",
    "name": "Logical NOT",
    "arity": 1,
    "keywords": ["logical", "not", "inverse", "boolean", "invert"],
    "tags": ["boolean", "vectorize"],
    "tagline": "Return <code>1</code> for falsy values and <code>0</code> otherwise.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "½",
    "id": "sqrt",
    "name": "Square Root",
    "arity": 1,
    "keywords": ["square", "root"],
    "tags": ["math", "number", "vectorize"],
    "tagline": "Returns the square root of the argument.",
    "description": "",
    "synonyms": ["*0.5$", "*.$"]
  },
  {
    "symbol": "!",
    "id": "factorial",
    "name": "Factorial / Pi Function",
    "arity": 1,
    "keywords": ["factorial"],
    "tags": ["math", "number", "vectorize"],
    "tagline": "Returns the factorial of the argument. For negative / non-integral values, return the result of the Pi function.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "A",
    "id": "abs",
    "name": "Absolute Value",
    "arity": 1,
    "keywords": ["absolute", "value", "positive"],
    "tags": ["math", "number", "vectorize"],
    "tagline": "Returns the absolute value (distance from zero) of the argument. Works for complex numbers.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "B",
    "id": "to-binary",
    "name": "Integer To Binary",
    "arity": 1,
    "keywords": ["convert", "conversion", "integer", "binary", "base", "2", "two"],
    "tags": ["math", "number", "array", "vectorize"],
    "tagline": "Converts an integer to its binary representation (list of digits).",
    "description": "For floating-point numbers, this atom adds the floating part to the last digit.",
    "synonyms": ["b2$"]
  },
  {
    "symbol": "C",
    "id": "complement",
    "name": "Complement",
    "arity": 1,
    "keywords": ["complement", "subtract", "1", "one"],
    "tags": ["math", "number", "vectorize"],
    "tagline": "Given <code>z</code>, compute <code>1 - z</code>.",
    "description": "",
    "synonyms": ["1_$"]
  },
  {
    "symbol": "D",
    "id": "to-decimal",
    "name": "Integer to Decimal",
    "arity": 1,
    "keywords": ["convert", "conversion", "integer", "decimal", "base", "10", "ten"],
    "tags": ["math", "number", "array", "vectorize"],
    "tagline": "Converts an integer to its decimal representation (list of digits)",
    "description": "For floating-point numbers, this atoms adds the floating part to the last digit.",
    "synonyms": ["b10$"]
  },
  {
    "symbol": "E",
    "id": "all-equal",
    "name": "All Equal",
    "arity": 1,
    "keywords": ["check", "all", "every", "equals"],
    "tags": ["array", "boolean"],
    "tagline": "Determine if all elements of a list are equal.",
    "description": "This is vacuously true for empty lists.",
    "synonyms": []
  },
  {
    "symbol": "F",
    "id": "flatten",
    "name": "Flatten List",
    "arity": 1,
    "keywords": ["flatten", "list", "array", "ravel"],
    "tags": ["array"],
    "tagline": "Flatten a list.",
    "description": "A flat list is a list such that every element is a single value (i.e. not a list itself). A way to think about it formally (as a recursive definition) is that a single value will be wrapped into a singleton list, and a list will have each element flattened and all elements concatenated together. Elements appear in the order of depth-first traversal.",
    "synonyms": ["ẎÐL"]
  },
  {
    "symbol": "G",
    "id": "grid",
    "name": "Format Grid",
    "arity": 1,
    "keywords": ["format", "grid", "2d", "two", "dimensional"],
    "tags": ["string", "array", "matrix"],
    "tagline": "Format a 2D array of values into a grid as a string.",
    "description": "Given a 2D array (a matrix) of values, attempt to convert it to a string such that the elements are right-aligned and spaced out evenly. It doesn't tend to work well if the array has more than two dimensions; it will try, but it often mixes spaces and/or newlines without properly converting to a string, which can cause strange output. This is mostly useful for rendering matrices of numbers or strings, either for ascii-art challenges or challenges with strict I/O formatting, or for debugging.",
    "synonyms": []
  },
  {
    "symbol": "H",
    "id": "halve",
    "name": "Halve",
    "arity": 1,
    "keywords": ["half", "halve", "divide", "2", "two"],
    "tags": ["math", "number"],
    "tagline": "Divide a number by two.",
    "description": "",
    "synonyms": ["÷2$"]
  },
  {
    "symbol": "I",
    "id": "increments",
    "name": "Increments",
    "arity": 1,
    "keywords": ["increments", "consecutive", "differences"],
    "tags": ["math", "number", "array", "vectorize"],
    "tagline": "Compute the consecutive forward differences of an array. Vectorizes at depth 1.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "J",
    "id": "range-of-length",
    "name": "Range of Length",
    "arity": 1,
    "keywords": ["range", "length", "index", "indices"],
    "tags": ["array", "number"],
    "tagline": "Given a list <code>z</code>, produce <code>[1, 2, ..., len(z)]</code>.",
    "description": "This atom can also be thought of as \"get the indices to access this list\". If the argument is a single value, this returns <code>[1]</code>.",
    "synonyms": ["LR$"]
  },
  {
    "symbol": "K",
    "id": "join-on-space",
    "name": "Join on Space",
    "arity": 1,
    "keywords": ["join", "spaces"],
    "tags": ["array", "string"],
    "tagline": "Join a list using spaces as the separator.",
    "description": "",
    "synonyms": ["j” $"]
  },
  {
    "symbol": "L",
    "id": "length",
    "name": "Length",
    "arity": 1,
    "keywords": ["length", "size"],
    "tags": ["array"],
    "tagline": "Get the length of an array. Single elements give <code>1</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "M",
    "id": "indices-of-max",
    "name": "Indices of Maximal Elements",
    "arity": 1,
    "keywords": ["indexes", "indices", "maximal", "maximum", "elements"],
    "tags": ["array", "optimization"],
    "tagline": "Find the indices of elements that are maximal in a list.",
    "description": "This atom will error on single values rather than automatically casting to range or singleton.",
    "synonyms": ["ẹṀ$"]
  },
  {
    "symbol": "N",
    "id": "negate",
    "name": "Negate",
    "arity": 1,
    "keywords": ["negate", "negative", "inverse", "invert", "additive"],
    "tags": ["math", "number", "vectorize"],
    "tagline": "Negate a number (multiply by <code>-1</code>).",
    "description": "",
    "synonyms": ["×-1$", "×-$", "0_$"]
  },
  {
    "symbol": "O",
    "id": "ord",
    "name": "Ord (character to codepoint)",
    "arity": 1,
    "keywords": ["ord", "codepoint", "character", "unicode"],
    "tags": ["string", "number", "vectorize"],
    "tagline": "Return the codepoint of a character. Numbers are left as-is.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "P",
    "id": "product",
    "name": "Product",
    "arity": 1,
    "keywords": ["product", "multiply", "multiplication", "reduce"],
    "tags": ["array", "math", "number"],
    "tagline": "Return the product of a list (left-reduce over <code>×</code> starting at <code>1</code>).",
    "description": "",
    "synonyms": ["×ƒ1", "×/"]
  },
  {
    "symbol": "Q",
    "id": "uniquify",
    "name": "Uniquify",
    "arity": 1,
    "keywords": ["unique", "uniquify", "remove", "duplicates", "values"],
    "tags": ["array"],
    "tagline": "Return the list with no duplicate elements, keeping the first occurrence of each.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "R",
    "id": "range",
    "name": "Range",
    "arity": 1,
    "keywords": ["range"],
    "tags": ["array", "number"],
    "tagline": "Return integers from 1 to N.",
    "description": "Floating point numbers get floored. Complex numbers cause an error. Non-positive integers return an empty list.",
    "synonyms": []
  },
  {
    "symbol": "S",
    "id": "sum",
    "name": "Sum",
    "arity": 1,
    "keywords": ["sum", "reduce", "addition"],
    "tags": ["math", "number", "array"],
    "tagline": "Return the sum of a list (left-reduce over <code>+</code> starting at <code>0</code>).",
    "description": "",
    "synonyms": ["+ƒ0", "+/"]
  },
  {
    "symbol": "T",
    "id": "truthy-indices",
    "name": "Indices of Truthy Values",
    "arity": 1,
    "keywords": ["indices", "indexes", "truthy", "true", "values", "mask", "boolean"],
    "tags": ["array", "boolean"],
    "tagline": "Return the indices of truthy values in a list.",
    "description": "Errors if given a single number; however, since characters are iterable (because they are single-character Python strings internally), they will just return <code>[1]</code>.",
    "synonyms": []
  },
  {
    "symbol": "U",
    "id": "upend",
    "name": "Upend / Reverse",
    "arity": 1,
    "keywords": ["upend", "reverse"],
    "tags": ["array", "vectorize"],
    "tagline": "Reverse an array. Vectorizes at depth 1.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "V",
    "id": "jelly-eval",
    "name": "Evaluate as Jelly Code",
    "arity": 1,
    "keywords": ["evaluate", "jelly", "source", "code"],
    "tags": ["vectorize"],
    "tagline": "Evaluate Jelly code niladically. Vectorizes at depth 1.",
    "description": "If the argument is a list, it applies Python's <code>str</code> function to each element and concatenates them before evaluating.",
    "synonyms": []
  },
  {
    "symbol": "W",
    "id": "wrap",
    "name": "Wrap",
    "arity": 1,
    "keywords": ["wrap", "surround", "singleton", "list"],
    "tags": ["array"],
    "tagline": "Wrap a value into a singleton array.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "X",
    "id": "random",
    "name": "Random Value",
    "arity": 1,
    "keywords": ["random", "choice", "randint"],
    "tags": ["random"],
    "tagline": "Random integer from <code>1</code> to </code>z</code> for an integer, or choose a random value from an array.",
    "description": "If the argument is a list, return a random value from it. For empty lists, return 0. If <code>z</code> is a positive integer, return a random integer from <code>1</code> to <code>z</code>. If <code>z</code> is <code>0</code>, return <code>0</code>. If <code>z</code> is negative, a decimal, or complex, error.",
    "synonyms": []
  },
  {
    "symbol": "Y",
    "id": "join-on-newline",
    "name": "Join on Newline",
    "arity": 1,
    "keywords": ["join", "newlines", "multiline", "lines", "breaks", "linefeeds"],
    "tags": ["array", "string"],
    "tagline": "Join a list using newlines as the separator.",
    "description": "",
    "synonyms": ["j”¶$"]
  },
  {
    "symbol": "Z",
    "id": "transpose",
    "name": "Zip / Transpose",
    "arity": 1,
    "keywords": ["zip", "transpose", "flip", "main", "diagonal"],
    "tags": ["matrix"],
    "tagline": "Transpose / flip a matrix; switch the rows and columns.",
    "description": "For a flat list, wraps it (each element becomes its own column, which means transpose then flips them all into one row). For a single value, if it's a number, error, and if it's a character, wrap it twice (because characters are internally single-character Python strings, which are iterable).",
    "synonyms": []
  },
  {
    "symbol": "~",
    "id": "bitwise-not",
    "name": "Bitwise NOT",
    "arity": 1,
    "keywords": ["bitwise", "not", "inverted", "inverse"],
    "tags": ["bitwise", "math", "number", "vectorized"],
    "tagline": "Compute the bitwise inverse of a number.",
    "description": "For integers, equivalent to <code>-1 - z</code>. Floating numbers get truncated. Complex numbers and single characters give <code>0</code>.",
    "synonyms": []
  },
  {
    "symbol": "°",
    "id": "deg-to-rad",
    "name": "Degress to Radians",
    "arity": 1,
    "keywords": ["convert", "conversion", "degrees", "radians", "angles"],
    "tags": ["math", "number", "vectorize"],
    "tagline": "Convert a number of degrees into its radian representation.",
    "description": "",
    "synonyms": ["÷180×ØPƊ"]
  },
  {
    "symbol": "¹",
    "id": "identity",
    "name": "Identity",
    "arity": 1,
    "keywords": ["identity", "self", "same"],
    "tags": [],
    "tagline": "Return the argument.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "²",
    "id": "square",
    "name": "Square",
    "arity": 1,
    "keywords": ["squared"],
    "tags": ["math", "number", "vectorize"],
    "tagline": "Square a number.",
    "description": "",
    "synonyms": ["*2$"]
  },
  {
    "symbol": "Ạ",
    "id": "all",
    "name": "All",
    "arity": 1,
    "keywords": ["all", "every", "element", "truthy", "true"],
    "tags": ["array", "boolean"],
    "tagline": "Given a list, return <code>0</code> if it contains a falsy value, and <code>1</code> otherwise.",
    "description": "Empty lists are vacuously true (as they do not contain a falsy value) and return <code>1</code>.",
    "synonyms": []
  },
  {
    "symbol": "Ḅ",
    "id": "from-binary",
    "name": "Binary to Integer",
    "arity": 1,
    "keywords": ["convert", "conversion", "binary", "integer", "base", "2", "two"],
    "tags": ["math", "number", "array"],
    "tagline": "Convert a list of digits from binary (base 2) to a number. Vectorizes at depth 1.",
    "description": "The digits don't actually need to be in the appropriate range or even integers. It just adds the last element, double the second last element, quadruple the third last element, etc.",
    "synonyms": ["ḅ2$"]
  },
  {
    "symbol": "Ḍ",
    "id": "from-decimal",
    "name": "Decimal to Integer",
    "arity": 1,
    "keywords": ["convert", "conversion", "decimal", "integer", "base", "10", "ten"],
    "tags": ["math", "number", "array"],
    "tagline": "Convert a list of digits from decimal (base 10) to a number. Vectorizes at depth 1.",
    "description": "The digits don't actually need to be in the appropriate range or even integers. It just adds the last element, ten times the second last element, one hundred times the third last element, etc.",
    "synonyms": ["ḅ10$"]
  },
  {
    "symbol": "Ẹ",
    "id": "any",
    "name": "Any",
    "arity": 1,
    "keywords": ["any", "truthy"],
    "tags": ["array", "boolean"],
    "tagline": "Given a list, return <code>1</code> if it contains a truthy value, and <code>0</code> otherwise.",
    "description": "Empty lists are vacuously false (as they do not contain a truthy value) and return <code>1</code>.",
    "synonyms": []
  },
  {
    "symbol": "Ḥ",
    "id": "double",
    "name": "Double",
    "arity": 1,
    "keywords": ["double", "multiply", "multiplication", "2", "two"],
    "tags": ["math", "number", "vectorize"],
    "tagline": "Double a number (multiply by two).",
    "description": "",
    "synonyms": ["×2$"]
  },
  {
    "symbol": "Ị",
    "id": "insignificant",
    "name": "insignificant",
    "arity": 1,
    "keywords": ["insignificant", "less", "than", "1", "one", "small"],
    "tags": ["math", "number", "vectorize"],
    "tagline": "insignificant; determine if the number's absolute value is less than or equal to 1.",
    "description": "In other words, it checks if a number is within the unit circle in the complex plain (including the edge). This is useful when you have a positive array and want to check for <code>1</code>s.",
    "synonyms": []
  },
  {
    "symbol": "Ḳ",
    "id": "split-at-space",
    "name": "Split at Space",
    "arity": 1,
    "keywords": ["split", "spaces"],
    "tags": ["string", "array"],
    "tagline": "Given a list (a string is a list of characters), split it at occurrences of <code>\" \"</code>.",
    "description": "",
    "synonyms": ["ṣ” $"]
  },
  {
    "symbol": "Ḷ",
    "id": "lowered-range",
    "name": "Lowered Range",
    "arity": 1,
    "keywords": ["lowered", "range"],
    "tags": ["array", "number", "vectorize"],
    "tagline": "Return the lowered range (from <code>0</code> to <code>z - 1</code>).",
    "description": "",
    "synonyms": ["R’$"]
  },
  {
    "symbol": "Ṃ",
    "id": "list-minimum",
    "name": "List Minimum",
    "arity": 1,
    "keywords": ["list", "minimum", "smallest", "least"],
    "tags": ["array", "number", "optimization"],
    "tagline": "Given a list, return its minimum value. Return the argument itself if it is a single value.",
    "description": "",
    "synonyms": ["«/"]
  },
  {
    "symbol": "Ṇ",
    "id": "logical-not-flat",
    "name": "Logical NOT (Flat)",
    "arity": 1,
    "keywords": ["logical", "not", "flat"],
    "tags": ["boolean"],
    "tagline": "Given a value, return <code>0</code> if it is truthy and <code>1</code> otherwise. Does not vectorize.",
    "description": "",
    "synonyms": ["¬'"]
  },
  {
    "symbol": "Ọ",
    "id": "chr",
    "name": "Chr (codepoint to character)",
    "arity": 1,
    "keywords": ["chr", "codepoint", "character", "unicode"],
    "tags": ["string", "number", "vectorize"],
    "tagline": "Return the character for a given codepoint. Characters are left as-is.",
    "description": "Floating-point numbers are truncated.",
    "synonyms": []
  },
  {
    "symbol": "Ṛ",
    "id": "reverse",
    "name": "Reverse (Flat)",
    "arity": 1,
    "keywords": ["reverse", "flat"],
    "tags": ["array"],
    "tagline": "Reverse a list. Does not vectorize.",
    "description": "",
    "synonyms": ["U'"]
  },
  {
    "symbol": "Ṣ",
    "id": "sort",
    "name": "Sort",
    "arity": 1,
    "keywords": ["sort", "order"],
    "tags": ["array", "combinatorics"],
    "tagline": "Sort a list from smallest to largest.",
    "description": "Sorting mixed lists may fail because it just directly compares the elements with Python's built-in comparison. If you need to sort a list of elements and some specific key function makes sense, consider the <a href='/quicks/sort-by'>Sort By Key Function (<code>Þ</code>)</a> quick.",
    "synonyms": []
  },
  {
    "symbol": "Ṭ",
    "id": "ones-at-indices",
    "name": "Ones at Indices",
    "arity": 1,
    "keywords": ["truthy", "ones", "indices", "indexes", "list", "array", "with", "values"],
    "tags": ["array", "number", "vectorize"],
    "tagline": "Return a boolean array with <code>1</code>s at the indices in the argument and <code>0</code>s elsewhere. Vectorizes at depth 1.",
    "description": "This is the right inverse of <a href='/atoms/truthy-indices'>Indices of Truthy Values (<code>T</code>)</a>.",
    "synonyms": []
  },
  {
    "symbol": "Ụ",
    "id": "grade-up",
    "name": "Grade Up",
    "arity": 1,
    "keywords": ["grade", "up", "list", "down"],
    "tags": ["array", "combinatorics"],
    "tagline": "Grade up a list; that is, sort its indices by the corresponding values.",
    "description": "Indexing the graded list into the list (<code>Ụị$</code>) sorts the list. Grading up twice returns a permutation of the same length as the list where larger elements in the permutation correspond to larger elemenets in the original list (it ranks the elements). You can negate the values before grading to grade down (<code>NỤ$</code>).",
    "synonyms": []
  },
  {
    "symbol": "Ṿ",
    "id": "uneval",
    "name": "Uneval",
    "arity": 1,
    "keywords": ["unevaluate", "representation", "jelly"],
    "tags": ["string"],
    "tagline": "Uneval; return a string that evaluates to the argument.",
    "description": "This is the right inverse of <a href='/atoms/jelly-eval'>Evaluate as Jelly Code (<code>V</code>)</a>.",
    "synonyms": []
  },
  {
    "symbol": "Ẉ",
    "id": "length-of-each",
    "name": "Length of Each",
    "arity": 1,
    "keywords": ["length", "each", "map", "size"],
    "tags": ["array"],
    "tagline": "Get the length of each element of the list.",
    "description": "If passed a number, implicitly convert it into a range (so, it becomes <code>[1]</code> repeated <code>z</code> times).",
    "synonyms": ["L€"]
  },
  {
    "symbol": "Ỵ",
    "id": "split-at-newline",
    "name": "Split at Newline",
    "arity": 1,
    "keywords": ["split", "newlines", "linefeeds", "lines", "breaks"],
    "tags": ["string", "array"],
    "tagline": "Given a list (a string is a list of characters), split it at occurrences of <code>\"\\n\"</code>.",
    "description": "",
    "synonyms": ["ṣ”¶$"]
  },
  {
    "symbol": "Ȧ",
    "id": "any-and-all",
    "name": "Any and All",
    "arity": 1,
    "keywords": ["any", "all", "some", "every"],
    "tags": ["array", "boolean"],
    "tagline": "Given a list, return <code>0</code> if the list is empty or contains a falsy value when flattened and <code>1</code> otherwise.",
    "description": "This is commonly used in place of <a href='/atoms/all'>All (<code>Ạ</code>)</a> to avoid the vacuous truth, but keep in mind that it flattens, so <code>1,[2,0],3 Ȧ</code> is <code>0</code> even though <code>1,[2,0],3 Ạ</code> and <code>1,[2,0],3 Ẹ</code> both give <code>1</code>.",
    "synonyms": []
  },
  {
    "symbol": "Ḃ",
    "id": "bit",
    "name": "Bit",
    "arity": 1,
    "keywords": ["bit", "modulo", "remainder", "2", "two", "parity", "even", "odd"],
    "tags": ["math", "number", "vectorize"],
    "tagline": "Returns <code>z % 2</code> (parity of <code>z</code> for integers).",
    "description": "",
    "synonyms": ["%2$"]
  },
  {
    "symbol": "Ċ",
    "id": "ceiling",
    "name": "Ceiling",
    "arity": 1,
    "keywords": ["ceiling", "round", "up", "nearest", "integer"],
    "tags": ["math", "number", "vectorize"],
    "tagline": "Round up to the nearest integer (real) / real part (complex).",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Ḋ",
    "id": "dequeue",
    "name": "Dequeue",
    "arity": 1,
    "keywords": ["dequeue", "every", "all", "remove", "except", "but", "first", "elements", "list", "starting", "second"],
    "tags": ["array"],
    "tagline": "Return all but the first element of a list (does not modify the list).",
    "description": "This will not error on empty lists because Python allows list slices to go out of range and just ignores the part that is out of bounds. For integers, auto-cast to range, so it returns <code>[2, 3, ..., z]</code>.",
    "synonyms": [""]
  },
  {
    "symbol": "Ė",
    "id": "enumerate",
    "name": "Enumerate",
    "arity": 1,
    "keywords": ["enumerate", "index", "each"],
    "tags": ["array"],
    "tagline": "Enumerate an array (<code>[[1, z[1]], [2, z[2]], ...]</code>).",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Ḟ",
    "id": "floor",
    "name": "Floor",
    "arity": 1,
    "keywords": ["floor", "round", "down", "nearest", "integer"],
    "tags": ["math", "number", "vectorize"],
    "tagline": "Round down to the nearest integer (real) / imaginary part (complex).",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Ġ",
    "id": "group-indices",
    "name": "Group Indices by Value",
    "arity": 1,
    "keywords": ["group", "indices", "corresponding", "values"],
    "tags": ["array"],
    "tagline": "Group the indices of a list by the corresponding values.",
    "description": "This returns a list of lists. Each number in <code>[1, 2, ..., len(z)]</code> will appear exactly once. Each sub-list will contain indices that map to the same value; that is, <code>i</code> and <code>j</code> are in the same sublist if and only if <code>z[i] == z[j]</code>. The sublists are ordered by the element they correspond to.",
    "synonyms": []
  },
  {
    "symbol": "Ḣ",
    "id": "head-monad",
    "name": "Head (First)",
    "arity": 1,
    "keywords": ["head", "first", "pop"],
    "tags": ["array"],
    "tagline": "Pop and return the first element of a list (modifies the list).",
    "description": "If the list is empty, returns zero. This mutates the original object itself, so <code>1,2,3 Ḣ,⁸Ɗ</code> yields <code>[1, [2, 3]]</code>, not <code>[1, [1, 2, 3]]</code>. If you do not want to modify the list, you can access the first element using <code>1ị$</code>; however, a clever trick you can employ is <code>ḷ/</code> (as long as your list isn't empty). This is technically less efficient because you reduce the whole list whereas random access is constant, but can save you a byte over <code>1ị$</code> if you would need the <code>$</code> to group those links.",
    "synonyms": []
  },
  {
    "symbol": "İ",
    "id": "reciprocal",
    "name": "Inverse / Reciprocal",
    "arity": 1,
    "keywords": ["multiplicative", "inverse", "reciprocal"],
    "tags": ["math", "number", "vectorize"],
    "tagline": "Return the reciprocal of a number.",
    "description": "The reciprocal of zero is infinity, which is consistent with <code>1 ÷ 0</code>.",
    "synonyms": ["1÷$"]
  },
  {
    "symbol": "Ṁ",
    "id": "list-maximum",
    "name": "List Maximum",
    "arity": 1,
    "keywords": ["list", "maximum", "largest", "biggest", "greatest"],
    "tags": ["array", "number", "optimization"],
    "tagline": "Given a list, return its maximum value. Return the argument itself if it is a single value.",
    "description": "",
    "synonyms": ["»/"]
  },
  {
    "symbol": "Ṅ",
    "id": "print-newline",
    "name": "Print (with newline)",
    "arity": 1,
    "keywords": ["print", "output", "stdout", "standard", "with", "newline", "linefeed", "line", "break"],
    "tags": ["stdio"],
    "tagline": "Output <code>z</code> to STDOUT, with a trailing newline, and return <code>z</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Ȯ",
    "id": "print",
    "name": "Print (without newline)",
    "arity": 1,
    "keywords": ["print", "output", "stdout", "standard", "without", "newline", "linefeed", "line", "break"],
    "tags": ["stdio"],
    "tagline": "Output <code>z</code> to STDOUT, without a trailing newline, and return <code>z</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Ṗ",
    "id": "pop",
    "name": "Pop",
    "arity": 1,
    "keywords": ["pop", "every", "all", "remove", "except", "but", "last", "elements", "list", "ending", "second"],
    "tags": ["array"],
    "tagline": "Return all but the last element of a list (does not modify the list).",
    "description": "This will not error on empty lists because Python allows list slices to go out of range and just ignores the part that is out of bounds. For integers, auto-cast to range, so it returns <code>[1, 3, ..., z - 1]</code>.",
    "synonyms": [""]
  },
  {
    "symbol": "Ṙ",
    "id": "print-repr",
    "name": "Print String Representation",
    "arity": 1,
    "keywords": ["print", "output", "stdout", "standard", "string", "representation", "without", "newline", "linefeed", "line", "break"],
    "tags": ["stdio"],
    "tagline": "Output a string representation of <code>z</code> to STDOUT, without a trailing newline, and return <code>z</code> itself.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Ṡ",
    "id": "sign",
    "name": "Sign / Conjugate",
    "arity": 1,
    "keywords": ["sign", "conjugate"],
    "tags": ["math", "number", "vectorize"],
    "tagline": "Return the sign (real), return the conjugate (complex).",
    "description": "For real numbers, if the number is positive, return <code>1</code>, if it is negative, return <code>-1</code>, and otherwise, return <code>0</code>. For a complex number <code>a + bi</code>, return <code>a - bi</code> (the <a href='https://en.wikipedia.org/wiki/Complex_conjugate'>complex conjugate</a>).",
    "synonyms": []
  },
  {
    "symbol": "Ṫ",
    "id": "tail-monad",
    "name": "Tail (First)",
    "arity": 1,
    "keywords": ["tail", "last", "pop"],
    "tags": ["array"],
    "tagline": "Pop and return the last element of a list (modifies the list).",
    "description": "If the list is empty, returns zero. This mutates the original object itself, so <code>1,2,3 Ṫ,⁸Ɗ</code> yields <code>[3, [1, 2]]</code>, not <code>[3, [1, 2, 3]]</code>. If you do not want to modify the list, you can access the last element using <code>0ị$</code>; however, a clever trick you can employ is <code>ṛ/</code> (as long as your list isn't empty). This is technically less efficient because you reduce the whole list whereas random access is constant, but can save you a byte over <code>0ị$</code> if you would need the <code>$</code> to group those links.",
    "synonyms": []
  },
  {
    "symbol": "Ẇ",
    "id": "sublists",
    "name": "Sublists",
    "arity": 1,
    "keywords": ["all", "every", "non", "empty", "nonempty", "sublists", "continuous", "contiguous", "slices", "substrings"],
    "tags": ["array", "combinatorics"],
    "tagline": "Return all non-empty contiguous slices ordered by increasing length then position.",
    "description": "The slices will be returned in increasing length, and for each length, they will be returned in left-to-right order based on their position in the original list. For example, <code>1,2,3Ẇ</code> returns <code>[[1], [2], [3], [1, 2], [2, 3], [1, 2, 3]]</code>.",
    "synonyms": []
  },
  {
    "symbol": "Ẋ",
    "id": "shuffle",
    "name": "Shuffle",
    "arity": 1,
    "keywords": ["shuffle", "randomly", "permute", "permutation", "reordering"],
    "tags": ["array", "combinatorics"],
    "tagline": "Return a random permutation of a list.",
    "description": "Numbers are automatically cast to a range.",
    "synonyms": ["Œ!X$"]
  },
  {
    "symbol": "Ẏ",
    "id": "tighten",
    "name": "Tighten",
    "arity": 1,
    "keywords": ["tighten", "dump", "flatten", "one", "1", "layer", "level", "sublists", "inside"],
    "tags": ["array"],
    "tagline": "Dump sublists inside the main list (flatten by one level).",
    "description": "Sublists will be concatenated together. Single values are wrapped into a singleton list.",
    "synonyms": [";/"]
  },
  {
    "symbol": "Ż",
    "id": "prepend-zero",
    "name": "Prepend Zero",
    "arity": 1,
    "keywords": ["prepend", "0", "zero", "range"],
    "tags": ["array", "number"],
    "tagline": "Prepend <code>0</code> to <code>z</code>. For integers, return <code>[0, 1, ..., z]</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "§",
    "id": "vectorizing-sum",
    "name": "Vectorizing Sum",
    "arity": 1,
    "keywords": ["vectorizing", "vectorized", "sum", "each", "addition", "reduce"],
    "tags": ["math", "number", "array", "vectorize"],
    "tagline": "Sum; vectorizes at depth 1.",
    "description": "For backwards compatibility, <code>ụ</code> works as well. Both are code point 225.",
    "synonyms": []
  },
  {
    "symbol": "Ä",
    "id": "cumulative-sum",
    "name": "Cumulative Sum",
    "arity": 1,
    "keywords": ["vectorizing", "vectorized", "cumulative", "sum", "scan", "addition", "reduce"],
    "tags": ["math", "number", "array", "vectorize"],
    "tagline": "Cumulative sum; vectorizes at depth 1.",
    "description": "For backwards compatibility, <code>ṿ</code> works as well, Both are code point 226.",
    "synonyms": ["+\\"]
  },
  {
    "symbol": "‘",
    "id": "increment",
    "name": "Increment",
    "arity": 1,
    "keywords": ["increment", "increase", "add", "1", "one"],
    "tags": ["math", "number", "vectorize"],
    "tagline": "Increment; add 1.",
    "description": "",
    "synonyms": ["+1$"]
  },
  {
    "symbol": "’",
    "id": "decrement",
    "name": "Decrement",
    "arity": 1,
    "keywords": ["decrement", "decrease", "subtract", "1", "one"],
    "tags": ["math", "number", "vectorize"],
    "tagline": "Decrement; subtract 1.",
    "description": "",
    "synonyms": ["_1$"]
  },
  {
    "symbol": "×",
    "id": "multiply",
    "name": "Multiply",
    "arity": 2,
    "keywords": ["multiply", "multiplication", "times"],
    "tags": ["math", "number", "vectorize"],
    "tagline": "Multiply two numbers.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "÷",
    "id": "divide",
    "name": "Divide",
    "arity": 2,
    "keywords": ["divide", "division", "ratio", "quotient"],
    "tags": ["math", "number", "vectorize"],
    "tagline": "Divide two numbers.",
    "description": "<code>÷ 0</code> will give <code>inf</code> for positive left arguments, <code>-inf</code> for negative left arguments, and <code>nan</code> for zero.",
    "synonyms": []
  },
  {
    "symbol": "%",
    "id": "modulo",
    "name": "Modulo",
    "arity": 2,
    "keywords": ["modulo", "modulus", "remainder", "divide", "division"],
    "tags": ["math", "number", "vectorize"],
    "tagline": "Remainder when dividing <code>x</code> by <code>y</code>.",
    "description": "This uses Python's <code>%</code>; that is, the result has the same sign as the right argument. Returns <code>nan</code> if the right argument is zero.",
    "synonyms": []
  },
  {
    "symbol": "&",
    "id": "bitwise-and",
    "name": "Bitwise AND",
    "arity": 2,
    "keywords": ["bitwise", "and", "intersection", "bits"],
    "tags": ["math", "number", "bitwise", "vectorize"],
    "tagline": "Bitwise AND.",
    "description": "Floating-point numbers are truncated.",
    "synonyms": []
  },
  {
    "symbol": "*",
    "id": "exponentiation",
    "name": "Exponentiation",
    "arity": 2,
    "keywords": ["exponentiation", "exponentiate", "power", "raise"],
    "tags": ["math", "number", "vectorize"],
    "tagline": "Return <code>x ** y</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": ",",
    "id": "pair",
    "name": "Pair",
    "arity": 2,
    "keywords": ["pair", "append", "join", "combine"],
    "tags": ["array"],
    "tagline": "Return <code>[x, y]</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": ":",
    "id": "integer-division",
    "name": "Integer Division",
    "arity": 2,
    "keywords": ["integer", "division", "divide", "floor"],
    "tags": ["math", "number", "vectorize"],
    "tagline": "Integer divide two numbers (floor).",
    "description": "The result is floored (not truncated), so <code>7 : 2</code> is <code>3</code> and <code>-7 : 2</code> is <code>-4</code>. Complex quotients will error.",
    "synonyms": []
  },
  {
    "symbol": ";",
    "id": "concatenate",
    "name": "Concatenate / Append",
    "arity": 2,
    "keywords": ["concatenate", "append", "join", "combine", "lists"],
    "tags": ["array"],
    "tagline": "Join two lists, prepend/append a value, or pair two values.",
    "description": "The exact behavior can be thought of as \"convert single-value arguments to singleton lists and then concatenate lists\" (in the same way Python <code>+</code> works on lists).",
    "synonyms": []
  },
  {
    "symbol": "<",
    "id": "less-than",
    "name": "Less Than",
    "arity": 2,
    "keywords": ["lesser", "than", "smaller"],
    "tags": ["math", "number", "boolean", "vectorize"],
    "tagline": "Return <code>1</code> if <code>x &lt; y</code> and <code>0</code> otherwise.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "=",
    "id": "equal-to",
    "name": "Equal To (Vectorizes)",
    "arity": 2,
    "keywords": ["equality", "same"],
    "tags": ["vectorize", "boolean"],
    "tagline": "Return <code>1</code> if <code>x == y</code> and <code>0</code> otherwise (vectorizes).",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": ">",
    "id": "greater-than",
    "name": "Greater Than",
    "arity": 2,
    "keywords": ["greater", "than", "larger", "bigger", "more"],
    "tags": ["math", "number", "boolean", "vectorize"],
    "tagline": "Return <code>1</code> if <code>x &gt; y</code> and <code>0</code> otherwise.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "^",
    "id": "bitwise-xor",
    "name": "Bitwise XOR",
    "arity": 2,
    "keywords": ["bitwise", "xor", "exclusive", "or"],
    "tags": ["math", "number", "bitwise", "vectorize"],
    "tagline": "Bitwise XOR.",
    "description": "Floating-point numbers are truncated. Exclusive OR returns <code>1</code> if <code>x</code> or <code>y</code> but not both, and <code>0</code> if neither or both are true (for each column of bits).",
    "synonyms": []
  },
  {
    "symbol": "_",
    "id": "subtraction",
    "name": "Subtraction",
    "arity": 2,
    "keywords": ["subtraction", "minus"],
    "tags": ["math", "number", "vectorize"],
    "tagline": "Return <code>x - y</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "a",
    "id": "logical-and",
    "name": "Logical AND",
    "arity": 2,
    "keywords": ["logical", "and", "intersection", "both", "truthy"],
    "tags": ["vectorize"],
    "tagline": "Return <code>y</code> if <code>x</code> is truthy and <code>x</code> otherwise.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "b",
    "id": "to-base",
    "name": "To Base",
    "arity": 2,
    "keywords": ["convert", "conversion", "base", "arbitrary"],
    "tags": ["math", "number", "array", "vectorize"],
    "tagline": "Convert <code>x</code> to base <code>y</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "c",
    "id": "combinations",
    "name": "Combinations",
    "arity": 2,
    "keywords": ["combinations", "xcy", "ncr"],
    "tags": ["math", "number", "vectorize", "combinatorics"],
    "tagline": "Return <code>xCy</code> (the number of ways of choosing <code>y</code> out of <code>x</code> objects).",
    "description": "<code>xCy</code> is the number of ways to select <code>y</code> objects out of a set of <code>x</code> objects, where the order does not matter. This can be represented as <code>x! / [ y! (x - y)! ]</code>.",
    "synonyms": []
  },
  {
    "symbol": "d",
    "id": "divmod",
    "name": "Divmod",
    "arity": 2,
    "keywords": ["divmod", "divide", "division", "modulo", "modulus", "remainder"],
    "tags": ["math", "number", "array", "vectorize"],
    "tagline": "Return <code>[x : y, x % y]</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "e",
    "id": "occurs",
    "name": "Occurs",
    "arity": 2,
    "keywords": ["occurs", "exists", "contains", "has", "existence"],
    "tags": ["array", "boolean"],
    "tagline": "Return <code>1</code> if <code>x</code> occurs in <code>y</code> and <code>0</code> otherwise.",
    "description": "This takes the element on the left and the list on the right. If you need the inverse, instead of <code>e@</code>, consider using <a href='/atoms/index-of'><code>i</code> (Index Of)</a>. It does not return a boolean value, but you can use it if you only need to check truthiness/falsiness.",
    "synonyms": []
  },
  {
    "symbol": "f",
    "id": "filter-include",
    "name": "Filter (Include)",
    "arity": 2,
    "keywords": ["filter", "set", "intersection", "keep", "remove", "not", "elements"],
    "tags": ["array"],
    "tagline": "Keep elements in <code>x</code> that are in <code>y</code> (remove elements in <code>x</code> that are not in <code>y</code>).",
    "description": "This also works as intersection if you don't have duplicate elements in the left argument or don't care about keeping them. If the counts of items in either argument matters, consider <a href='/atoms/multiset-intersection'><code>œ&</code> (Multiset Intersection)</a>.",
    "synonyms": []
  },
  {
    "symbol": "g",
    "id": "gcd",
    "name": "GCD",
    "arity": 2,
    "keywords": ["gcd", "hcf", "greatest", "highest", "common", "divisor", "factor"],
    "tags": ["math", "number", "vectorize"],
    "tagline": "Return the largest number that divides both <code>x</code> and <code>y</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "i",
    "id": "index-of",
    "name": "Index Of",
    "arity": 2,
    "keywords": ["indexof", "find"],
    "tags": ["array", "number"],
    "tagline": "Find the first index of <code>y</code> in list <code>x</code>, or <code>0</code> if the element is not present.",
    "description": "Automatically casts the left argument to a singleton list if needed. This takes the element on the right and the list on the left, which is opposite of <a href='/atoms/occurs'><code>e</code> (Occurs)</a>. If you want to check if an element exists in a list and want the list on the left, consider using this instead of <code>e</code> - even though it returns the index and not a boolean value, since Jelly is 1-indexed, <code>0</code>, the value returned if the element is not found, is the only falsy output, and thus indicates if the element is in the list.",
    "synonyms": []
  },
  {
    "symbol": "j",
    "id": "join",
    "name": "Join",
    "arity": 2,
    "keywords": ["join", "with", "on", "arbitrary", "separator"],
    "tags": ["array"],
    "tagline": "Join the list <code>x</code> with some separator <code>y</code>.",
    "description": "Each sublist of <code>x</code> is concatenated with <code>y</code> in between. Essentially, this functions as <code>x[1] ; y ; x[2] ; y ; x[3] ; ... ; x[-1] ; y ; x[0]</code>.",
    "synonyms": []
  },
  {
    "symbol": "k",
    "id": "partition-after-truthy-indices",
    "name": "Partition After Truthy Indices",
    "arity": 2,
    "keywords": ["partition", "after", "at", "truthy", "true", "indices", "indexes"],
    "tags": ["array", "number", "boolean", "combinatorics"],
    "tagline": "Partition <code>y</code> after the truthy indices in <code>x</code>.",
    "description": "At each truthy index in <code>x</code>, cut the <code>y</code> (essentially, each truthy index in <code>x</code> will be the last element in a sub-list of the result). If the last element of <code>y</code> is at a truthy index, there will be a trailing empty list. For example, <code>0,0,1,0,1 k 10R¤</code> returns <code>[[1, 2, 3], [4, 5], [6, 7, 8, 9, 10]]</code> and <code>0,0,1,0,1 k 5R¤</code> returns <code>[[1, 2, 3], [4, 5], []]</code>.",
    "synonyms": []
  },
  {
    "symbol": "l",
    "id": "logarithm",
    "name": "Logarithm",
    "arity": 2,
    "keywords": ["logarithm", "base"],
    "tags": ["math", "number", "vectorize"],
    "tagline": "Logarithm of <code>x</code> with base <code>y</code>.",
    "description": "If <code>y</code> is <code>1</code> or <code>0</code>, returns <code>None</code>, even if <code>x == y</code>. Works with negative and complex arguments and can find complex answers.",
    "synonyms": []
  },
  {
    "symbol": "m",
    "id": "modular",
    "name": "Modular",
    "arity": 2,
    "keywords": ["modular", "every", "nth", "yth", "element"],
    "tags": ["array", "number", "vectorize"],
    "tagline": "Return every <code>y</code>th element of <code>x</code>.",
    "description": "Automatically casts the left argument to a singleton list if needed. Vectorizes on the right argument. If <code>y</code> is <code>0</code>, return <code>x</code> concatenated with its reverse. Otherwise, it is equivalent to <code>x[::y]</code> in Python (and works with negative <code>y</code>, returning elements in reverse order).",
    "synonyms": []
  },
  {
    "symbol": "n",
    "id": "not-equal-to",
    "name": "Not Equal To (Vectorizes)",
    "arity": 2,
    "keywords": ["not", "equals", "unequal", "inequal"],
    "tags": ["boolean", "vectorize"],
    "tagline": "Return <code>1</code> if <code>x != y</code> and <code>0</code> otherwise (vectorizes).",
    "description": "",
    "synonyms": ["=¬¥"]
  },
  {
    "symbol": "o",
    "id": "logical-or",
    "name": "Logical OR",
    "arity": 2,
    "keywords": ["logical", "or", "union", "either", "truthy"],
    "tags": ["vectorize"],
    "tagline": "Return <code>x</code> if <code>x</code> is truthy and <code>y</code> otherwise.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "p",
    "id": "cartesian-product",
    "name": "Cartesian Product",
    "arity": 2,
    "keywords": ["cartesian", "product", "pairs"],
    "tags": ["array", "combinatorics"],
    "tagline": "Return a list of all pairs of elements from <code>x</code> and <code>y</code>.",
    "description": "Rather than returning a table, cartesian product returns a flat list of pairs (it is not really flat because its elements are pairs, but for two flat lists, it will return a depth-2 list rather than a depth-3 list). Elements are ordered firstly by order in <code>x</code> and then in <code>y</code>. The left argument is cast to a singleton list, but the right argument is cast to a range. For example, <code>1,2 p 3,4</code> gives <code>[[1, 3], [1, 4], [2, 3], [2, 4]]</code>, <code>1 p 2,3</code> gives <code>[[1, 2], [1, 3]]</code>, and <code>1,2 p 3</code> gives <code>[[1, 1], [1, 2], [1, 3], [2, 1], [2, 2], [2, 3]]</code>.",
    "synonyms": []
  },
  {
    "symbol": "r",
    "id": "inclusive-range",
    "name": "Inclusive Range",
    "arity": 2,
    "keywords": ["inclusive", "range"],
    "tags": ["array", "numbers", "vectorize"],
    "tagline": "Return the inclusive range from <code>x</code> to <code>y</code>, descending if <code>x &gt; y</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "s",
    "id": "split-length",
    "name": "Split (Length)",
    "arity": 2,
    "keywords": ["split", "into", "slices", "length"],
    "tags": ["array", "numbers", "vectorize"],
    "tagline": "Return <code>x</code> sliced into chunks of length <code>y</code>.",
    "description": "Vectorizes over the right argument. If the length of <code>x</code> is not divisible by <code>y</code>, the last chunk will be shorter. Numbers are automatically cast to a range on the left. For example, <code>5 s 2</code> returns <code>[[1, 2], [3, 4], [5]]</code>.",
    "synonyms": []
  },
  {
    "symbol": "t",
    "id": "trim",
    "name": "Trim",
    "arity": 2,
    "keywords": ["trim", "strip", "remove", "edges", "sides"],
    "tags": ["array"],
    "tagline": "Trim the elements of <code>y</code> from the sides of <code>x</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "v",
    "id": "jelly-eval-with-argument",
    "name": "Evaluate as Jelly Code (with an argument)",
    "arity": 2,
    "keywords": ["evaluate", "jelly", "source", "code", "with", "argument"],
    "tags": ["vectorize"],
    "tagline": "Evaluate <code>x</code> as Jelly source code monadically with <code>y</code> as the argument.",
    "description": "If the left argument is a list, stringify each element, join them together, and evaluate. Vectorizes at depth 1 on the left argument.",
    "synonyms": []
  },
  {
    "symbol": "w",
    "id": "index-of-sublist",
    "name": "Index Of Sublist",
    "arity": 2,
    "keywords": ["indexof", "find", "sublist", "substring"],
    "tags": ["array", "number"],
    "tagline": "Find the first index of <code>y</code> as a sublist in list <code>x</code>, or <code>0</code> if the sublist is not present.",
    "description": "Automatically casts both arguments to singleton lists if needed. This takes the element on the right and the list on the left, which is opposite of <a href='/atoms/sublist-occurs'><code>ẇ</code> (Sublist Occurs)</a>. If you want to check if a sublist exists in a list and want the list on the left, consider using this instead of <code>ẇ@</code> - even though it returns the index and not a boolean value, since Jelly is 1-indexed, <code>0</code>, the value returned if the element is not found, is the only falsy output, and thus indicates if the element is in the list.",
    "synonyms": []
  },
  {
    "symbol": "x",
    "id": "replicate",
    "name": "Replicate",
    "arity": 2,
    "keywords": ["repeat", "times", "replicate"],
    "tags": ["array", "number", "vectorize"],
    "tagline": "Repeat each element of <code>x</code> <code>y</code> times. Vectorizes at depth 1 on the left and then vectorizes between the elements.",
    "description": "<code>y</code> must be a list of only numbers or a number, otherwise an error will occur. This repeats each element of <code>x</code> in-place, so <code>1,2,3,4 x 2,1,3,2</code> returns <code>[1, 1, 2, 3, 3, 3, 4, 4]</code>. If the right argument consists of only <code>0</code> and <code>1</code>, this works to apply a boolean mask to a list.",
    "synonyms": []
  },
  {
    "symbol": "y",
    "id": "translate",
    "name": "Translate",
    "arity": 2,
    "keywords": ["translate", "mapping", "apply"],
    "tags": ["array"],
    "tagline": "Translate <code>y</code> based on the mapping defined by <code>x</code>.",
    "description": "<code>x</code> must be an even-length list. Each pair defines a mapping, and the mappings are applied in sequence. Then, the first list in each pair defines the source and the second list defines the destination. If the destination list is shorter, the last element is repeated as many times as needed.<br /><br />For example, <code>5R 1,2,2,3y</code> returns <code>[3, 3, 3, 4, 5]</code> because the <code>1</code> is mapped to a <code>2</code>, and then both <code>2</code>s are mapped to <code>3</code>. However, <code>5R [1,2],[2,3]y</code> returns <code>[2, 3, 3, 4, 5]</code> because there is only one mapping which is applied in parallel. Note that <code>[a,b],[c,d]y</code> maps <code>a</code> to <code>c</code>, not <code>b</code>. <code>10R [1,2,3],[4,5]y</code> returns <code>[4, 5, 5, 4, 5, 6, 7, 8, 9, 10]</code> - the <code>1</code> maps to <code>4</code>, the <code>2</code> maps to <code>5</code>, and the <code>3</code> also maps to <code>5</code> because the destination list's last element is repeated if necessary.",
    "synonyms": []
  },
  {
    "symbol": "z",
    "id": "zip-with-filler",
    "name": "Zip With Filler",
    "arity": 2,
    "keywords": ["zip", "transpose", "with", "filler", "padding"],
    "tags": ["array", "matrix"],
    "tagline": "Transpose the rows and columns of a 2D array <code>x</code>. If <code>x</code> is not rectangular, <code>y</code> is used as filler.",
    "description": "Note that this does not vectorize over the right argument - <code>[1,2,3],[4],[5,6] z [1,2]</code> gives <code>[[1, 4, 5], [2, [1, 2], 6], [3, [1, 2], [1, 2]]]</code>.",
    "synonyms": []
  },
  {
    "symbol": "|",
    "id": "bitwise-or",
    "name": "Bitwise OR",
    "arity": 2,
    "keywords": ["bitwise", "or", "union", "bits"],
    "tags": ["math", "number", "bitwise", "vectorize"],
    "tagline": "Bitwise OR.",
    "description": "Floating-point numbers are truncated.",
    "synonyms": []
  },
  {
    "symbol": "⁼",
    "id": "equal-to-flat",
    "name": "Equal To (Flat)",
    "arity": 2,
    "keywords": ["equality", "same", "flat", "non", "vectorizing", "nonvectorizing"],
    "tags": ["boolean"],
    "tagline": "Return <code>1</code> if <code>x == y</code> and <code>0</code> otherwise (does not vectorize).",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "⁻",
    "id": "not-equal-to-flat",
    "name": "Not Equal To (Flat)",
    "arity": 2,
    "keywords": ["not", "equals", "unequal", "inequal", "flat", "non", "vectorizing", "nonvectorizing"],
    "tags": ["boolean"],
    "tagline": "Return <code>1</code> if <code>x != y</code> and <code>0</code> otherwise (does not vectorize).",
    "description": "",
    "synonyms": ["⁼¬¥"]
  },
  {
    "symbol": "ạ",
    "id": "absolute-difference",
    "name": "Absolute Difference",
    "arity": 2,
    "keywords": ["absolute", "difference"],
    "tags": ["math", "number", "vectorize"],
    "tagline": "Return <code>abs(x - y)</code>.",
    "description": "",
    "synonyms": ["_A¥"]
  },
  {
    "symbol": "ḅ",
    "id": "from-base",
    "name": "From Base",
    "arity": 2,
    "keywords": ["convert", "conversion", "base", "arbitrary"],
    "tags": ["math", "number", "array", "vectorize"],
    "tagline": "Convert <code>x</code> from base <code>y</code>. Vectorizes at depth 1 (left) and 0 (right).",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ḍ",
    "id": "divisibility",
    "name": "Divisibility",
    "arity": 2,
    "keywords": ["divides", "divisible", "divisibility", "factor", "divisor"],
    "tags": ["math", "number", "vectorize"],
    "tagline": "Return <code>1</code> if <code>x</code> divides <code>y</code> and <code>0</code> otherwise.",
    "description": "This atom takes the factor/divisor on the left. If you want to have the divisor on the right, rather than using <code>ḍ@</code>, consider <a href='/atoms/multiplicity'><code>ọ</code> (Order / Multiplicity)</a>, which returns the number of times the left argument is divisible by the right argument (the greatest power of the right argument that divides the left argument). It does not return a boolean, but if you only need to check truthiness, <code>ọ/code> should work.",
    "synonyms": []
  },
  {
    "symbol": "ẹ",
    "id": "all-indices",
    "name": "All Indices",
    "arity": 2,
    "keywords": ["all", "indices", "indexes", "find", "findall"],
    "tags": ["array", "number"],
    "tagline": "Return the indices of all occurrences of <code>y</code> in <code>x</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ḥ",
    "id": "hash",
    "name": "Hash",
    "arity": 2,
    "keywords": ["hashcode"],
    "tags": ["array", "number"],
    "tagline": "Jelly's Hash Function. Given a magic number (like a salt) and an input, yield a value from a collection.",
    "description": "<code>x</code> contains a magic number, similar to a salt (tt can also be a base-250 compressed integer in string form), concatenated with a collection of values. If <code>x</code> has more than two values, the first is the magic number and the remainder of the list is the collection. If the second value if <code>x</code> is a number <code>N</code>, it is converted into <code>[1, 2, ..., N]</code>. Then, <code>y</code> is used as input to the hash function. An item from the collection is returned based on this hash. The hash function is defined in <a href='https://github.com/DennisMitchell/jellylanguage/blob/master/jelly/interpreter.py#L424'><code>jelly_hash</code></a>.",
    "synonyms": []
  },
  {
    "symbol": "ị",
    "id": "index-into",
    "name": "Element At Index",
    "arity": 2,
    "keywords": ["get", "element", "index", "into", "at", "access", "list"],
    "tags": ["array", "number", "vectorize"],
    "tagline": "Return the element of <code>y</code> at index <code>x</code>. If <code>x</code> isn't an integer, return <code>[y[floor(x)], y[ceil(x)]]</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ḷ",
    "id": "left-argument",
    "name": "Left Argument",
    "arity": 2,
    "keywords": ["left", "argument"],
    "tags": [],
    "tagline": "Return <code>x</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ṃ",
    "id": "base-decompression",
    "name": "Base Decompression",
    "arity": 2,
    "keywords": ["base", "decompression", "convert", "conversion", "index", "into"],
    "tags": ["array", "number"],
    "tagline": "Convert <code>x</code> into base <code>len(y)</code> and then index into <code>y</code>.",
    "description": "This is a good way to encode a list of repetitive values that don't form an easily compressible pattern. For example, to represent the string <code>\"abcabbacbbcabcbbacbacbcbacb\"</code>, there is no good pattern to it, but if you index into <code>\"abc\"</code> (using <code>0</code> for the last element instead of <code>3</code>, so it can be converted into the appropriate base), you obtain the list <code>[1, 2, 0, 1, 2, 2, 1, 0, 2, 2, 0, 1, 2, 0, 2, 2, 1, 0, 2, 1, 0, 2, 0, 2, 1, 0, 2]</code>, which is <code>4418814364301</code> in base 3, which can be <a href='/misc/integer-compressor'>compressed</a> into <code>“¤²5÷Ṫ2’</code>. Thus, <code>“¤²5÷Ṫ2’ṃ“abc”</code> decodes as <code>\"abcabbacbbcabcbbacbacbcbacb\"</code>, which saves 14 bytes, even including the trailing <code>¤</code> to combine it into a single nilad. Note that the index of the first value must not be zero when you are compressing, because base decoding does not produce leading zeroes.<br /><br />You can generate these compressed forms <a href='/misc/base-compressor'>here</a>.",
    "synonyms": ["bL}¹ịʋ"]
  },
  {
    "symbol": "ọ",
    "id": "multiplicity",
    "name": "Order / Multiplicity",
    "arity": 2,
    "keywords": ["order", "multiplicity", "valuation", "divisibility", "divisible", "divides", "factor", "divisor"],
    "tags": ["math", "number", "vectorize"],
    "tagline": "Return the number of times <code>x</code> is divisible by <code>y</code>.",
    "description": "For example, <code>1134 ọ 3<code> returns <code>4</code> because <code>1134 = 3⁴ × 2 × 5</code>. This takes its arguments in reverse order to <a href='/atoms/divisibility'><code>ḍ</code> (Divisibility)</a> (this takes the divisor on the right), and returns a non-zero value if and only if <code>x</code> is divisible by <code>y</code> at least once, so if you only need to check truthiness, consider using this atom if you need the factor on the right.",
    "synonyms": []
  },
  {
    "symbol": "ṛ",
    "id": "right-argument",
    "name": "Right Argument",
    "arity": 2,
    "keywords": ["right", "argument"],
    "tags": [],
    "tagline": "Return <code>y</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ṣ",
    "id": "split-at-occurrences",
    "name": "Split At occurrences",
    "arity": 2,
    "keywords": ["split", "list", "instances", "occurrences", "elements"],
    "tags": ["array"],
    "tagline": "Split <code>x</code> at occurrences of <code>y</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ṭ",
    "id": "tack",
    "name": "Tack",
    "arity": 2,
    "keywords": ["tack", "append", "prepend"],
    "tags": ["array"],
    "tagline": "Append <code>x</code> to <code>y</code>.",
    "description": "<code>x</code> will not be concatenated but will rather just be appended directly, so this is <code>y + [x]</code> in Python, so this is distinct from <code>;@</code>.",
    "synonyms": ["W;@¥"]
  },
  {
    "symbol": "ȧ",
    "id": "logical-and-flat",
    "name": "Logical AND (Flat)",
    "arity": 2,
    "keywords": ["logical", "and", "intersection", "both", "truthy", "flat", "non", "vectorizing", "nonvectorizing"],
    "tags": [],
    "tagline": "Return <code>y</code> if <code>x</code> is truthy and <code>x</code> otherwise (does not vectorize).",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ḃ",
    "id": "to-bijective-base",
    "name": "To Bijective Base",
    "arity": 2,
    "keywords": ["convert", "conversion", "bijective", "base"],
    "tags": ["math", "number", "array", "vectorize"],
    "tagline": "Convert <code>x</code> to bijective base <code>y</code> (digits are <code>[1, 2, ..., y]</code> rather than <code>[0, 1, ..., y - 1]</code>).",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ċ",
    "id": "count-occurrences",
    "name": "Count Occurrences",
    "arity": 2,
    "keywords": ["count", "occurrences", "instances", "copies", "number", "times", "shows", "up", "appears"],
    "tags": ["array", "number"],
    "tagline": "Count the number of occurrences of <code>y</code> within <code>x</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ḋ",
    "id": "dot-product",
    "name": "Dot Product",
    "arity": 2,
    "keywords": ["dot", "inner", "product"],
    "tags": ["math", "number", "array", "vectorize"],
    "tagline": "Return the dot product of <code>x</code> and <code>y</code>, padding the shorter argument with <code>0</code>s (vectorizes at depth 1 on both sides).",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ḟ",
    "id": "filter-exclude",
    "name": "Filter (Exclude)",
    "arity": 2,
    "keywords": ["filter", "set", "difference", "keep", "remove", "not", "elements"],
    "tags": ["array"],
    "tagline": "Keep elements in <code>x</code> that are not in <code>y</code> (remove elements in <code>x</code> that are in <code>y</code>).",
    "description": "This also works as set difference if you don't have duplicate elements in the left argument or don't care about keeping them. If the counts of items in either argument matters, consider <a href='/atoms/multiset-difference'><code>œ-</code> (Multiset Difference)</a>.",
    "synonyms": []
  },
  {
    "symbol": "ḣ",
    "id": "head-dyad",
    "name": "Head",
    "arity": 2,
    "keywords": ["first", "y", "head", "slice"],
    "tags": ["array", "number", "vectorize"],
    "tagline": "First <code>y</code> elements; return <code>x[:y]</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ṁ",
    "id": "mold",
    "name": "Mold (Reshape)",
    "arity": 2,
    "keywords": ["mold", "reshape"],
    "tags": ["array"],
    "tagline": "Reshape the elements of <code>x</code> into the structure of <code>y</code>.",
    "description": "Specifically, the elements of <code>x</code> (automatically cast to a singleton list) are cycled through to fill the elements of <code>y</code> in the order they would appear if <code>y</code> were <a href='/atoms/flatten'>Flattened (<code>F</code>)</a>. <code>x</code> is not flattened, however, so <code>[1,2],3 ṁ 1,2,[3,4]</code> returns <code>[[1, 2], 3, [[1, 2], 3]]</code>.",
    "synonyms": []
  },
  {
    "symbol": "ȯ",
    "id": "logical-or-flat",
    "name": "Logical OR (Flat)",
    "arity": 2,
    "keywords": ["logical", "or", "union", "either", "truthy", "flat", "non", "vectorizing", "nonvectorizing"],
    "tags": [],
    "tagline": "Return <code>x</code> if <code>x</code> is truthy and <code>y</code> otherwise (does not vectorize).",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ṗ",
    "id": "cartesian-power",
    "name": "Cartesian Power",
    "arity": 2,
    "keywords": ["cartesian", "power", "all", "every", "tuples"],
    "tags": ["math", "number", "array", "combinatorics", "vectorize"],
    "tagline": "Return all lists of <code>y</code> elements of <code>x</code> (duplicates are allowed).",
    "description": "Returns a flat list of length <code>len(x) ** y</code> containing all combinations, with duplicates, of <code>y</code> elements of <code>x</code>, ordered lexicographically by order of appearance in <code>x</code>.",
    "synonyms": []
  },
  {
    "symbol": "ṙ",
    "id": "rotate",
    "name": "Rotate",
    "arity": 2,
    "keywords": ["rotate", "list", "left"],
    "tags": ["array", "number", "vectorize"],
    "tagline": "Rotate the list <code>x</code> to the left <code>y</code> times.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ṡ",
    "id": "split-length-overlapping",
    "name": "Split (Length, Overlapping)",
    "arity": 2,
    "keywords": ["split", "into", "slices", "length", "overlapping"],
    "tags": ["array", "numbers", "vectorize"],
    "tagline": "Return overlapping slices of <code>x</code> of length <code>y</code>.",
    "description": "Vectorizes over the right argument. If the length of <code>x</code> is less than <code>y</code>, returns the empty list. Numbers are automatically cast to a range on the left. For example, <code>5 ṡ 3</code> returns <code>[[1, 2, 3], [2, 3, 4], [3, 4, 5]]</code>.",
    "synonyms": []
  },
  {
    "symbol": "ṫ",
    "id": "tail-dyad",
    "name": "Tail",
    "arity": 2,
    "keywords": ["all", "every", "except", "first", "y", "tail", "slice"],
    "tags": ["array", "number", "vectorize"],
    "tagline": "Return the elements of <code>y</code> starting at index <code>x</code>; return <code>x[y - 1:]</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ẇ",
    "id": "sublist-occurs",
    "name": "Sublist Occurs",
    "arity": 2,
    "keywords": ["sublist", "occurs", "exists", "contains", "has", "existence"],
    "tags": ["array", "boolean"],
    "tagline": "Return <code>1</code> if <code>x</code> occurs as a contiguous sublist in <code>y</code> and <code>0</code> otherwise.",
    "description": "This takes the element on the left and the list on the right. If you need the inverse, instead of <code>ẇ@</code>, consider using <a href='/atoms/index-of-sublist'><code>w</code> (Index Of Sublist)</a>. It does not return a boolean value, but you can use it if you only need to check truthiness/falsiness.",
    "synonyms": []
  },
  {
    "symbol": "ẋ",
    "id": "repeat",
    "name": "Repeat",
    "arity": 2,
    "keywords": ["repeat", "list"],
    "tags": ["array", "number", "vectorize"],
    "tagline": "Repeat list <code>x</code> <code>y</code> times.",
    "description": "Unlike <a href='/atoms/replicate'><code>x</code> (Replicate)</a>, this does not vectorize between the values, but rather at depth 0 on the right. It simply concatenates <code>y</code> copies of <code>x</code> together.",
    "synonyms": []
  },
  {
    "symbol": "ż",
    "id": "interleave",
    "name": "Zip (Interleave)",
    "arity": 2,
    "keywords": ["zip", "interleave", "pairs"],
    "tags": ["array"],
    "tagline": "Interleave <code>x</code> and <code>y</code>, returning pairs of elements and trailing single elements from the longer list.",
    "description": "",
    "synonyms": [",\""]
  },
  {
    "symbol": "«",
    "id": "minimum",
    "name": "Minimum",
    "arity": 2,
    "keywords": ["minimum", "smaller", "lesser"],
    "tags": ["math", "number", "vectorize"],
    "tagline": "Return the minimum of <code>x</code> and <code>y</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "»",
    "id": "maximum",
    "name": "Maximum",
    "arity": 2,
    "keywords": ["maximum", "greater", "larger", "bigger"],
    "tags": ["math", "number", "vectorize"],
    "tagline": "Return the maximum of <code>x</code> and <code>y</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Ø½",
    "id": "one-two",
    "name": "[1, 2]",
    "arity": 0,
    "keywords": ["constant", "onetwo"],
    "tags": ["constant", "array", "number"],
    "tagline": "Return <code>[1, 2]</code>.",
    "description": "",
    "synonyms": ["1,2"]
  },
  {
    "symbol": "Ø%",
    "id": "4294967296",
    "name": "4294967296",
    "arity": 0,
    "keywords": ["constant", "4294967296", "2", "32", "thirtytwo"],
    "tags": ["constant", "number"],
    "tagline": "Return <code>4294967296</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Ø(",
    "id": "parentheses",
    "name": "Parentheses",
    "arity": 0,
    "keywords": ["constant", "parentheses", "round", "brackets"],
    "tags": ["constant", "string"],
    "tagline": "Return <code>\"()\"</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Ø+",
    "id": "signs",
    "name": "Signs",
    "arity": 0,
    "keywords": ["constant", "signs", "one", "1", "positive", "negative", "minus"],
    "tags": ["constant", "array", "number"],
    "tagline": "Return <code>[1, -1]</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Ø-",
    "id": "signs-inverted",
    "name": "Signs (Inverted)",
    "arity": 0,
    "keywords": ["constant", "signs", "one", "1", "positive", "negative", "minus"],
    "tags": ["constant", "array", "number"],
    "tagline": "Return <code>[-1, 1]</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Ø.",
    "id": "bits",
    "name": "Bits",
    "arity": 0,
    "keywords": ["constant", "bits", "01", "zeroone"],
    "tags": ["constant", "array", "number"],
    "tagline": "Return <code>[0, 1]</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Ø0",
    "id": "zeroes",
    "name": "Zeroes",
    "arity": 0,
    "keywords": ["constant", "zeroes", "00", "zeropair", "zerozero", "zerotwo", "ゼロツー", "darling"],
    "tags": ["constant", "array", "number"],
    "tagline": "Return <code>[0, 0]</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Ø1",
    "id": "ones",
    "name": "Ones",
    "arity": 0,
    "keywords": ["constant", "ones", "11", "onepair", "oneone"],
    "tags": ["constant", "array", "number"],
    "tagline": "Return <code>[1, 1]</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Ø2",
    "id": "twos",
    "name": "Twos",
    "arity": 0,
    "keywords": ["constant", "twos", "22", "twopair", "twotwo"],
    "tags": ["constant", "array", "number"],
    "tagline": "Return <code>[2, 2]</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Ø<",
    "id": "angle-brackets",
    "name": "Angle Brackets",
    "arity": 0,
    "keywords": ["constant", "angle", "brackets"],
    "tags": ["constant", "string"],
    "tagline": "Return <code>\"<>\"</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ØA",
    "id": "alphabet-upper",
    "name": "Alphabet (Uppercase)",
    "arity": 0,
    "keywords": ["constant", "alphabet", "abcdefghijklmnopqrstuvwxyz", "uppercase", "capital"],
    "tags": ["constant", "string"],
    "tagline": "Return <code>\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ØB",
    "id": "base-digits",
    "name": "Base Digits",
    "arity": 0,
    "keywords": ["constant", "base", "digits", "0123456789abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"],
    "tags": ["constant", "string"],
    "tagline": "Return <code>\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ØḄ",
    "id": "consonants-lower",
    "name": "Consonants (Lowercase)",
    "arity": 0,
    "keywords": ["constant", "consonants", "with", "including", "include", "y", "lowercase", "bcdfghjklmnpqrstvwxyz"],
    "tags": ["constant", "string"],
    "tagline": "Return <code>\"bcdfghjklmnpqrstvwxyz\"</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ØḂ",
    "id": "consonants-upper",
    "name": "Consonants (Uppercase)",
    "arity": 0,
    "keywords": ["constant", "consonants", "with", "including", "include", "y", "uppercase", "capital", "bcdfghjklmnpqrstvwxyz"],
    "tags": ["constant", "string"],
    "tagline": "Return <code>\"BCDFGHJKLMNPQRSTVWXYZ\"</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ØC",
    "id": "consonants-all",
    "name": "Consonants (All)",
    "arity": 0,
    "keywords": ["constant", "consonants", "with", "including", "include", "y", "all", "bcdfghjklmnpqrstvwxyzbcdfghjklmnpqrstvwxyz"],
    "tags": ["constant", "string"],
    "tagline": "Return <code>\"BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\"</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ØD",
    "id": "digits",
    "name": "Digits",
    "arity": 0,
    "keywords": ["constant", "decimal", "digits", "0123456789"],
    "tags": ["constant", "string"],
    "tagline": "Return <code>\"0123456789\"</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ØH",
    "id": "hexadecimal-digits-uppercase",
    "name": "Hexadecimal Digits (Uppercase)",
    "arity": 0,
    "keywords": ["constant", "hexadecimal", "digits", "uppercase", "capital", "0123456789abcdef"],
    "tags": ["constant", "string"],
    "tagline": "Return <code>\"0123456789ABCDEF\"</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ØJ",
    "id": "jelly-codepage",
    "name": "Jelly's Codepage",
    "arity": 0,
    "keywords": ["constant", "jelly", "codepage", "charset", "character", "set"],
    "tags": ["constant", "string"],
    "tagline": "Return Jelly's codepage (<code>\"¡¢£¤¥...»‘’“”\"</code>).",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ØP",
    "id": "pi",
    "name": "Pi",
    "arity": 0,
    "keywords": ["constant", "pi"],
    "tags": ["constant", "math", "number"],
    "tagline": "Return <code>3.141592653589793</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ØQ",
    "id": "qwerty-upper",
    "name": "QWERTY (Uppercase)",
    "arity": 0,
    "keywords": ["constant", "keyboard", "qwertyuiop", "asdfghjkl", "zxcvbnm", "uppercase", "capital"],
    "tags": ["constant", "array"],
    "tagline": "Return <code>[\"QWERTYUIOP\", \"ASDFGHJKL\", \"ZXCVBNM\"]</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ØV",
    "id": "quine-cheat",
    "name": "\"ṘV\" (Quine Cheat)",
    "arity": 0,
    "keywords": ["constant", "quine", "cheat", "rv"],
    "tags": ["constant", "string"],
    "tagline": "Return <code>\"ṘV\"</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ØW",
    "id": "word",
    "name": "Word",
    "arity": 0,
    "keywords": ["constant", "word", "characters"],
    "tags": ["constant", "string"],
    "tagline": "Return <code>\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_\"</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ØY",
    "id": "consonants-no-y-all",
    "name": "Consonants (No Y, All)",
    "arity": 0,
    "keywords": ["constant", "consonants", "without", "excluding", "exclude", "no", "y", "all", "bcdfghjklmnpqrstvwxzbcdfghjklmnpqrstvwxz"],
    "antiwords": ["with"],
    "tags": ["constant", "string"],
    "tagline": "Return <code>\"BCDFGHJKLMNPQRSTVWXZbcdfghjklmnpqrstvwxz\"</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Ø[",
    "id": "square-brackets",
    "name": "Square Brackets",
    "arity": 0,
    "keywords": ["constant", "square", "brackets"],
    "tags": ["constant", "string"],
    "tagline": "Return <code>\"[]\"</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Ø^",
    "id": "slashes",
    "name": "Slashes",
    "arity": 0,
    "keywords": ["constant", "slashes"],
    "tags": ["constant", "string"],
    "tagline": "Return <code>\"/\\\"</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Øa",
    "id": "alphabet-lower",
    "name": "Alphabet (Lowercase)",
    "arity": 0,
    "keywords": ["constant", "alphabet", "lowercase", "abcdefghijklmnopqrstuvwxyz"],
    "tags": ["constant", "string"],
    "tagline": "Return <code>\"abcdefghijklmnopqrstuvwxyz\"</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Øb",
    "id": "base-64-digits",
    "name": "Base 64 Digits",
    "arity": 0,
    "keywords": ["constant", "base64", "b64", "digits", "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789"],
    "tags": ["constant", "string"],
    "tagline": "Return <code>\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Øc",
    "id": "vowels-all",
    "name": "Vowels (All)",
    "arity": 0,
    "keywords": ["constant", "vowels", "without", "excluding", "exclude", "no", "y", "all", "aeiou"],
    "antiwords": ["with"],
    "tags": ["constant", "string"],
    "tagline": "Return <code>\"AEIOUaeiou\"</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Øe",
    "id": "euler-number",
    "name": "Euler's Number",
    "arity": 0,
    "keywords": ["constant", "e", "euler", "s", "number", "exponential"],
    "tags": ["constant", "math", "number"],
    "tagline": "Return <code>2.718281828459045</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Øh",
    "id": "hexadecimal-digits-lowercase",
    "name": "Hexadecimal Digits (Lowercase)",
    "arity": 0,
    "keywords": ["constant", "hexadecimal", "digits", "lowercase", "0123456789abcdef"],
    "tags": ["constant", "string"],
    "tagline": "Return <code>\"0123456789abcdef\"</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Øp",
    "id": "phi",
    "name": "Phi (Golden Ratio)",
    "arity": 0,
    "keywords": ["constant", "phi", "golden", "ratio"],
    "tags": ["constant", "math", "number"],
    "tagline": "Return <code>1.618033988749895</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Øq",
    "id": "qwerty-lower",
    "name": "QWERTY (Lowercase)",
    "arity": 0,
    "keywords": ["constant", "keyboard", "qwertyuiop", "asdfghjkl", "zxcvbnm", "lowercase"],
    "tags": ["constant", "string", "array"],
    "tagline": "Return <code>[\"qwertyuiop\", \"asdfghjkl\", \"zxcvbnm\"]</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Øv",
    "id": "quine-cheat-lower",
    "name": "\"Ṙv\" (Payload-capable Quine Cheat)",
    "arity": 0,
    "keywords": ["constant", "quine", "cheat", "rv"],
    "tags": ["constant", "string"],
    "tagline": "Return <code>\"Ṙv\"</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Øy",
    "id": "vowels-y-all",
    "name": "Vowels (With Y, All)",
    "arity": 0,
    "keywords": ["constant", "vowels", "with", "including", "include", "y", "all", "aeiouyaeiouy"],
    "tags": ["constant", "string"],
    "tagline": "Return <code>\"AEIOUYaeiouy</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Ø{",
    "id": "curly-braces",
    "name": "Curly Braces",
    "arity": 0,
    "keywords": ["constant", "curly", "brackets", "braces"],
    "tags": ["constant", "string"],
    "tagline": "Return <code>\"{}\"</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Ø°",
    "id": "360",
    "name": "360",
    "arity": 0,
    "keywords": ["constant", "360", "three", "hundred", "sixty", "threehundredsixty", "threesixty"],
    "tags": ["constant", "number"],
    "tagline": "Return <code>360</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Ø⁵",
    "id": "250",
    "name": "250",
    "arity": 0,
    "keywords": ["constant", "250", "two", "hundred", "fifth", "twohundredfifty", "twofifty"],
    "tags": ["constant", "number"],
    "tagline": "Return <code>250</code> (Jelly's integer compression base).",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Ø⁷",
    "id": "128",
    "name": "128",
    "arity": 0,
    "keywords": ["constant", "128", "one", "hundred", "twenty", "eight", "onehundredtwentyeight", "onetwentyeight", "onetwoeight"],
    "tags": ["constant", "number"],
    "tagline": "Return <code>128</code> (<code>2⁷</code>).",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ØẠ",
    "id": "alphabet-all",
    "name": "Alphabet (All)",
    "arity": 0,
    "keywords": ["constant", "alphabet", "all", "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"],
    "tags": ["constant", "string"],
    "tagline": "Return <code>\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ØỴ",
    "id": "consonants-no-y-lower",
    "name": "Consonants (No Y, Lowercase)",
    "arity": 0,
    "keywords": ["constant", "consonants", "without", "excluding", "exclude", "no", "y", "lowercase", "bcdfghjklmnpqrstvwxz"],
    "antiwords": ["with"],
    "tags": ["constant", "string"],
    "tagline": "Return <code>\"bcdfghjklmnpqrstvwxz\"</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Øẹ",
    "id": "vowels-lower",
    "name": "Vowels (Lowercase)",
    "arity": 0,
    "keywords": ["constant", "vowels", "without", "excluding", "exclude", "no", "y", "lowercase", "aeiou"],
    "antiwords": ["with"],
    "tags": ["constant", "string"],
    "tagline": "Return <code>\"aeiou\"</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Øỵ",
    "id": "vowels-y-lower",
    "name": "Vowels (With Y, Lowercase)",
    "arity": 0,
    "keywords": ["constant", "vowels", "with", "including", "include", "y", "lowercase", "aeiouy"],
    "tags": ["constant", "string"],
    "tagline": "Return <code>\"aeiouy\"</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ØṖ",
    "id": "printable-ascii",
    "name": "Printable ASCII",
    "arity": 0,
    "keywords": ["constant", "printable", "ascii"],
    "tags": ["constant", "string"],
    "tagline": "Return <code>\" !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\"</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "ØẎ",
    "id": "consonants-no-y-upper",
    "name": "Consonants (No Y, Uppercase)",
    "arity": 0,
    "keywords": ["constant", "consonants", "without", "excluding", "exclude", "no", "y", "uppercase", "capital", "bcdfghjklmnpqrstvwxz"],
    "antiwords": ["with"],
    "tags": ["constant", "string"],
    "tagline": "Return <code>\"BCDFGHJKLMNPQRSTVWXZ\"</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Øė",
    "id": "vowels-upper",
    "name": "Vowels (Uppercase)",
    "arity": 0,
    "keywords": ["constant", "vowels", "without", "excluding", "exclude", "no", "y", "uppercase", "capital", "aeiou"],
    "antiwords": ["with"],
    "tags": ["constant", "string"],
    "tagline": "Return <code>\"AEIOU\"</code>.",
    "description": "",
    "synonyms": []
  },
  {
    "symbol": "Øẏ",
    "id": "vowels-y-upper",
    "name": "Vowels (With Y, Uppercase)",
    "arity": 0,
    "keywords": ["constant", "vowels", "with", "including", "include", "y", "uppercase", "capital", "aeiouy"],
    "tags": ["constant", "string"],
    "tagline": "Return <code>\"AEIOUY\"</code>.",
    "description": "",
    "synonyms": []
  }
]
